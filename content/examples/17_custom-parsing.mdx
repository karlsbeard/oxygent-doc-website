---
title: Custom Parsing Function
description: The following uses character matching for simulation. In production environments, typically retrieve top-K relevant content from knowledge base based on query, and can add multi-path retrieval logic
---

## Overview

This example demonstrates custom parsing function in OxyGent.

## Code

```python
import os
from oxygent import MAS, oxy, Config, OxyRequest
from oxygent.schemas import LLMResponse, LLMState
from pydantic import Field

Config.set_agent_llm_model("default_llm")

jd_docs_fh = oxy.FunctionHub(name="jd_docs_tools")

@jd_docs_fh.tool(description="A tool that can retrieve JD-related knowledge")
def retrieval(query: str = Field(description="What aspect of knowledge")) -> str:
    """The following uses character matching for simulation. In production environments, typically retrieve top-K relevant content from knowledge base based on query, and can add multi-path retrieval logic"""
    knowledage_dict = {
        "211_delivery": "**JD 211 Delivery Service**: Orders placed before 11:00 AM (or 10:00 AM in some cities) are delivered the same day; orders placed before 11:00 PM are delivered by 3:00 PM the next day. (Note: Timing starts from order submission for in-stock orders, and from payment completion for prepaid orders)",
        "mission": "JD's mission is 'Technology for a Better Life'.",
        "vision": "JD's vision is to become the world's most trusted company.",
        "values": "JD's core values are: Customer First, Innovation, Fighting Spirit, Responsibility, Gratitude, and Integrity.",
    }
    return "\n\n".join([v for k, v in knowledage_dict.items() if k in query])

note_prompt = """
You are an assistant that helps users take notes, format as follows:
[June 18, 2025 10:00] Location Meeting
[November 11, 2025 Evening] On Duty
You should first get the time using Shanghai timezone, then record to note.txt file in local_file folder, create if file doesn't exist.

You can use these tools:
${tools_description}

Choose appropriate tools based on user's question.
If no tools needed, reply directly.
If answering user's question requires multiple tool calls, call one tool at a time, user will give you feedback on tool call results.

Important:
1. When you have enough information to answer user's question, please respond in the following format:
<answer>
<think>Your thinking (if analysis needed)</think>
Your answer content
</answer>
2. When you find the user's question lacks conditions, you can ask back, please respond in the following format:
<answer>
<think>Your thinking (if analysis needed)</think>
Your question to the user
</answer>
3. When you need to use a tool, you must only respond with the exact JSON object format below, nothing else:
<tool>
<think>Your thinking (if analysis needed)</think>
<tool_name>Tool name</tool_name>
<arguments>
<Parameter name 1>Parameter value 1</Parameter name 1>
<Parameter name 2>Parameter value 2</Parameter name 2>
</arguments>
</tool>

After receiving tool response:
1. Convert raw data to natural conversational response
2. Answer should be concise but informative
3. Focus on most relevant information
4. Use appropriate context from user's question
5. Avoid simply repeating raw data

Please only use the tools explicitly defined above.
"""

# Custom parsing function for LLM output
def parse_llm_response(ori_response: str, oxy_request: OxyRequest = None) -> LLMResponse:
    try:
        import xml.etree.ElementTree as ET
        # Parse XML and extract information
        root = ET.fromstring(ori_response)
        if root.find('tool_name') is not None:
            tool_call_dict = {
                "tool_name": root.find('tool_name').text,
                "arguments": {child.tag: child.text for child in root.find('arguments')}
            }
            return LLMResponse(
                state=LLMState.TOOL_CALL,
                output=tool_call_dict,
                ori_response=ori_response,
            )
        else:
            think_content = root.find('think').text if root.find("think") else ""
            answer_content = ''.join(root.itertext()).replace(think_content, '').strip()
            return LLMResponse(
                state=LLMState.ANSWER,
                output=answer_content,
                ori_response=ori_response,
            )
    except Exception as e:
        return LLMResponse(
            state=LLMState.ERROR_PARSE, output=e, ori_response=ori_response
        )

oxy_space = [
    oxy.HttpLLM(
        name="default_llm",
        api_key=os.getenv("DEFAULT_LLM_API_KEY"),
        base_url=os.getenv("DEFAULT_LLM_BASE_URL"),
        model_name=os.getenv("DEFAULT_LLM_MODEL_NAME"),
        llm_params={"temperature": 0.1},
    ),
    jd_docs_fh,
    oxy.StdioMCPClient(
        name="time_tools",
        params={
            "command": "uvx",
            "args": ["mcp-server-time", "--local-timezone=Asia/Shanghai"],
        },
    ),
    oxy.StdioMCPClient(
        name="file_tools",
        params={
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-filesystem", "./local_file"],
        },
    ),
    oxy.ReActAgent(
        name="QA_agent",
        desc="An assistant that can query JD knowledge",
        tools=["jd_docs_tools"],
    ),
    oxy.ReActAgent(
        name="time_agent",
        desc="An assistant that can query time",
        tools=["time_tools"],
    ),
    oxy.ReActAgent(
        name="file_agent",
        desc="An assistant that can operate files",
        tools=["file_tools"],
    ),
    oxy.ReActAgent(
        name="note_agent",
        desc="A life assistant that takes notes",
        prompt=note_prompt,
        sub_agents=["time_agent", "file_agent"],
        func_parse_llm_response=parse_llm_response,   # Register LLM output parsing function
    ),
    oxy.ReActAgent(
        name="master_agent",
        is_master=True,
        sub_agents=["QA_agent", "note_agent"],
    ),
]

async def main():
    async with MAS(oxy_space=oxy_space) as mas:
        await mas.start_web_service(first_query="Help me create a reminder: meeting at 3 PM in room 618")

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

## Key Points

- This example shows how to use OxyGent for custom parsing function
- Follow the code comments for detailed explanations
- Make sure to set up your environment variables before running

## Running the Example

To run this example:

```bash
python 17_custom_parsing.py
```
