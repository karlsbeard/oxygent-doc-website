---
title: SSEMCPClient API 参考
description: SSEMCPClient 类的完整 API 参考文档
icon: Code
---

## 类定义

```python
from oxygent import oxy

# 创建 SSEMCPClient 实例
client = oxy.SSEMCPClient(
    name="remote_tools",
    sse_url="http://127.0.0.1:9000/sse",
    headers={"Authorization": "Bearer token"},
    middlewares=[]
)
```

## 构造函数参数

### 必需参数

|参数|类型|必需|默认值|描述|
|-----------|------|----------|---------|-------------|
| `name` | `str` | **是** | - | MCP 客户端的唯一标识符。代理在其 `tools` 列表中引用此名称 |
| `sse_url` | `AnyUrl` | **是** | `""` | SSE 端点 URL（例如 "http://localhost:9000/sse"） |

### 可选参数

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `middlewares` | `list[Any]` | `[]` | 用于请求/响应处理的客户端 MCP 中间件列表 |

### 从 BaseMCPClient 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `headers` | `dict[str, str]` | `{}` | 随所有请求发送的 HTTP 头 |
| `is_dynamic_headers` | `bool` | `False` | 启用每个请求的动态头更新 |
| `is_inherit_headers` | `bool` | `False` | 从 OxyRequest._headers 继承头 |
| `is_keep_alive` | `bool` | 配置默认值 | 在调用之间保持 SSE 连接活动 |

### 从 BaseTool 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `timeout` | `float` | `60` | 每次工具调用的最大执行时间（秒） |
| `semaphore` | `int` | `16` | 最大并发工具执行数 |
| `retries` | `int` | `2` | 失败时的重试次数 |
| `delay` | `float` | `1.0` | 重试尝试之间的延迟（秒） |
| `is_permission_required` | `bool` | `True` | 代理是否需要权限来调用工具 |
| `is_save_data` | `bool` | `True` | 是否保存执行跟踪 |

### 内部属性

|属性|类型|描述|
|-----------|------|-------------|
| `included_tool_name_list` | `list[str]` | 从 MCP 服务器发现的工具名称列表 |
| `_session` | `ClientSession` | MCP 协议会话（在 `init()` 期间初始化） |
| `_exit_stack` | `AsyncExitStack` | 用于清理的资源管理上下文 |

## 参数详情

### name

- **类型**: `str`
- **必需**: 是
- **描述**: 在多智能体系统中此 SSE MCP 客户端的唯一标识符。代理在其 `tools` 列表中引用此名称以使用此远程服务器提供的所有工具。

**示例:**
```python
oxy.SSEMCPClient(
    name="remote_api_tools",  # 代理将在其工具列表中使用 "remote_api_tools"
    ...
)
```

### sse_url

- **类型**: `AnyUrl` (Pydantic URL 类型)
- **必需**: 是
- **描述**: 托管 SSE MCP 服务器的 HTTP(S) URL 端点。此 URL 必须指向服务器的 SSE 端点。

**格式:**
- 必须是有效的 URL
- 通常以 `/sse` 或类似路径结尾
- 可以是 HTTP（本地/开发）或 HTTPS（生产）

**示例:**
```python
# 本地开发
sse_url="http://localhost:9000/sse"
sse_url="http://127.0.0.1:8000/mcp/sse"

# 生产环境
sse_url="https://api.example.com/mcp/sse"
sse_url="https://tools.myapp.com/sse"
```

**URL 处理:**
URL 通过 `build_url()` 工具处理，该工具:
- 确保格式正确
- 处理尾随斜杠
- 验证 URL 结构

### headers

- **类型**: `dict[str, str]`
- **默认**: `{}`
- **描述**: 包含在所有发送到 SSE 服务器的请求中的 HTTP 头。通常用于身份验证、版本控制和自定义元数据。

**常见用例:**

1. **身份验证:**
```python
headers={
    "Authorization": "Bearer your-api-token",
    "X-API-Key": os.getenv("MCP_API_KEY")
}
```

2. **API 版本控制:**
```python
headers={
    "X-API-Version": "v2",
    "Accept": "application/json"
}
```

3. **自定义元数据:**
```python
headers={
    "X-Client-ID": "oxygent-client",
    "X-Application": "my-app",
    "X-Environment": "production"
}
```

**行为:**
- 头信息随每个 SSE 连接发送
- 如果 `is_dynamic_headers=True` 可以按请求覆盖
- 如果继承，`host` 头会自动移除

### is_dynamic_headers

- **类型**: `bool`
- **默认**: `False`
- **描述**: 启用按请求基础的动态头更新。启用时，可以在工具调用中提供头信息，这些头信息将覆盖/合并基础头信息。

**要求:**
- 必须设置 `is_keep_alive=False` 才能使动态头工作
- 为每个工具调用创建新的 SSE 连接

**示例:**
```python
# 启用动态头
oxy.SSEMCPClient(
    name="dynamic_client",
    sse_url="http://localhost:9000/sse",
    headers={
        "X-Service-Key": "default-key"  # 基础头
    },
    is_dynamic_headers=True,
    is_keep_alive=False  # 必需
)

# 稍后，在工具调用中:
await oxy_request.call(
    callee="tool_name",
    arguments={"param": "value"},
    headers={  # 这些会合并/覆盖基础头
        "X-User-ID": "user123",
        "X-Request-ID": "req456"
    }
)
```

### is_inherit_headers

- **类型**: `bool`
- **默认**: `False`
- **描述**: 从 OxyRequest 上下文（`_headers` 字段）继承头信息。用于通过调用链传播上游头信息。

**行为:**
- 如果 `is_inherit_headers=True`，读取 `oxy_request.shared_data.get("_headers", {})`
- 自动移除 `host` 头（防止冲突）
- 与基础 `headers` 和动态 `headers` 合并
- 合并顺序: `基础头 | 继承头 | 动态头`

**示例:**
```python
oxy.SSEMCPClient(
    name="inherit_client",
    sse_url="http://localhost:9000/sse",
    is_dynamic_headers=True,
    is_inherit_headers=True,  # 从请求上下文继承
    is_keep_alive=False
)

# 带头信息的上游请求
await mas.call(
    callee="agent",
    arguments={
        "messages": [...],
        "_headers": {  # 这些将被继承
            "X-Trace-ID": "trace123",
            "X-User-Context": "user-data"
        }
    }
)
```

### is_keep_alive

- **类型**: `bool`
- **默认**: 来自 `Config.get_tool_mcp_is_keep_alive()`
- **描述**: 控制 SSE 连接生命周期和持久性。

**True (持久连接):**
- 在 `init()` 期间建立单个 SSE 连接
- 连接被所有工具调用重用
- 更快的性能（无重连开销）
- 工具在启动时发现一次
- 不能使用动态头
- **推荐用于大多数用例**

**False (临时连接):**
- 为每个工具调用创建新的 SSE 连接
- 每次都是新状态
- 动态头所必需
- 由于重连导致更高延迟
- 每次重新发现工具

**示例:**
```python
# 持久连接（默认，推荐）
oxy.SSEMCPClient(
    name="persistent",
    sse_url="http://localhost:9000/sse",
    is_keep_alive=True  # 默认
)

# 临时连接（用于动态头）
oxy.SSEMCPClient(
    name="transient",
    sse_url="http://localhost:9000/sse",
    is_dynamic_headers=True,
    is_keep_alive=False  # 动态头所必需
)
```

### middlewares

- **类型**: `list[Any]`
- **默认**: `[]`
- **描述**: 用于处理请求和响应的客户端中间件对象列表。中间件必须实现 MCP ClientSession 期望的中间件接口。

**接口:**
中间件应该具有以下方法:
- `process_request(request)` - 在发送请求前调用
- `process_response(response)` - 在接收响应后调用

**示例:**
```python
class LoggingMiddleware:
    async def process_request(self, request):
        print(f"[REQUEST] {request}")
        return request

    async def process_response(self, response):
        print(f"[RESPONSE] {response}")
        return response

class AuthMiddleware:
    def __init__(self, token):
        self.token = token

    async def process_request(self, request):
        request.headers["Authorization"] = f"Bearer {self.token}"
        return request

oxy.SSEMCPClient(
    name="middleware_client",
    sse_url="http://localhost:9000/sse",
    middlewares=[
        LoggingMiddleware(),
        AuthMiddleware(os.getenv("TOKEN"))
    ]
)
```

**兼容性说明:**
- 中间件支持取决于 MCP 客户端库版本
- 如果 `session.add_middleware()` 不可用，会记录警告
- 在不兼容版本中中间件会被静默忽略

### timeout

- **类型**: `float`
- **默认**: `60`
- **描述**: 每个工具调用的最大执行时间（秒）。适用于整个请求-响应周期。

**使用指南:**
- 快速工具: 10-30 秒
- API 调用: 30-60 秒
- 数据处理: 60-120 秒
- 长时间操作: 120+ 秒

**示例:**
```python
oxy.SSEMCPClient(
    name="slow_tools",
    sse_url="http://api.slow-service.com/sse",
    timeout=180  # 3 minutes for slow operations
)
```

## 方法

### init()

初始化到 MCP 服务器的 SSE 连接。

```python
async def init(self, is_fetch_tools: bool = True) -> None
```

**参数:**
- `is_fetch_tools` (bool): 初始化后是否自动发现和注册工具。默认: `True`

**行为：**

行为取决于 `is_dynamic_headers` 和 `is_keep_alive`：

**情况 1：持久连接（`is_keep_alive=True` 且 `not is_dynamic_headers`）**
1. 使用 `headers` 建立到 `sse_url` 的 SSE 连接
2. 通过 SSE 传输创建 MCP `ClientSession`
3. 将所有 `middlewares` 添加到会话
4. 初始化 MCP 协议
5. 如果 `is_fetch_tools=True`，通过 `list_tools()` 发现工具

**情况 2：临时连接（`is_keep_alive=False` 或 `is_dynamic_headers=True`）**
1. 创建临时 SSE 连接
2. 通过 `list_tools()` 发现工具
3. 立即关闭连接
4. 后续工具调用创建新连接

**错误处理:**
- 如果初始化失败，记录包含服务器名称的错误
- 出错时自动调用 `cleanup()`
- 抛出包含消息"Server \{name\} error"的 `Exception`

**示例（内部使用）：**
```python
# 在初始化期间由 MAS 自动调用
async with MAS(oxy_space=[client, ...]) as mas:
    # client.init() 在这里被调用
    ...
```

### call_tool()

在 SSE MCP 服务器上执行工具。

```python
async def call_tool(
    self,
    tool_name: str,
    arguments: dict,
    headers: dict[str, str] = None
) -> Any
```

**参数:**
- `tool_name` (str): 要调用的工具名称
- `arguments` (dict): 工具特定的参数
- `headers` (dict, optional): 为此调用覆盖/合并的头

**返回：** 包含工具执行结果的 MCP 响应对象

**行为：**
1. 使用 `build_url(sse_url)` 构建 URL
2. 使用提供的/合并的头建立 SSE 客户端连接
3. 创建临时 ClientSession
4. 初始化 MCP 协议
5. 使用参数调用指定的工具
6. 返回响应
7. 自动关闭连接

**注意：** 当 `is_keep_alive=False` 或 `is_dynamic_headers=True` 时使用此方法。对于持久连接，`_execute()` 使用现有会话。

**示例（内部使用）：**
```python
# 在每个请求创建新连接时内部调用
response = await client.call_tool(
    tool_name="fetch_data",
    arguments={"url": "https://api.example.com/data"},
    headers={"X-Request-ID": "req123"}
)
```

### list_tools()

从 SSE MCP 服务器发现并注册工具。

```python
async def list_tools(self) -> None
```

**行为：**
1. 检查 `_session` 是否已初始化（持久模式）
2. 通过 MCP 协议调用 `_session.list_tools()`
3. 调用 `add_tools()` 创建 `MCPTool` 包装器
4. 在 MAS 中注册每个工具

**抛出：**
- 如果服务器未初始化（仅持久模式），抛出 `RuntimeError`

**注意：** 在临时模式下，此方法在 `init()` 期间使用临时会话调用。

**示例（内部使用）：**
```python
# 如果 is_fetch_tools=True，在 init() 期间自动调用
await client.list_tools()
```

### add_tools()

为发现的工具创建 MCPTool 包装器。

```python
def add_tools(self, tools_response) -> None
```

**参数:**
- `tools_response`: 来自 `list_tools()` 的响应，包含工具定义

**行为：**
1. 提取排除敏感字段的模型转储
2. 遍历响应中的工具
3. 为每个工具创建一个 `MCPTool` 实例，包含:
   - 工具名称和描述
   - 对此 SSE MCP 客户端的引用
   - 输入模式
   - 钩子函数（如果已配置）
4. 在 MAS 中注册每个 `MCPTool`
5. 将工具名称添加到 `included_tool_name_list`

**从模型转储中排除的字段：**
- `sse_url`
- `server_url`
- `headers`
- `middlewares`
- `included_tool_name_list`
- `name`
- `desc`
- `mcp_client`
- `server_name`
- `input_schema`

**示例（内部使用）：**
```python
# 由 list_tools() 调用
tools_response = await session.list_tools()
client.add_tools(tools_response)
```

### cleanup()

清理 SSE MCP 服务器资源和连接。

```python
async def cleanup(self) -> None
```

**行为：**
1. 获取清理锁以防止并发清理
2. 关闭 `AsyncExitStack`（关闭 SSE 连接和会话）
3. 优雅地处理 `asyncio.CancelledError`
4. 抑制其他异常以防止级联失败
5. 将 `_session` 和 `_stdio_context` 设置为 `None`

**何时调用：**
- MAS 退出时自动调用
- 初始化错误时自动调用
- 如果需要可以手动调用

**示例（通常自动）：**
```python
# 自动清理
async with MAS(oxy_space=[client, ...]) as mas:
    ...
# cleanup() 在这里自动调用
```

## 使用示例

### 基础远程连接

```python
from oxygent import MAS, oxy
import os

# 简单的远程 MCP 服务器
client = oxy.SSEMCPClient(
    name="remote_tools",
    sse_url="http://127.0.0.1:9000/sse"
)

oxy_space = [
    oxy.HttpLLM(name="llm", ...),
    client,
    oxy.ReActAgent(
        name="agent",
        llm_model="llm",
        tools=["remote_tools"]
    )
]
```

### 使用身份验证

```python
# 认证的远程服务器
secure_client = oxy.SSEMCPClient(
    name="secure_tools",
    sse_url="https://api.example.com/mcp/sse",
    headers={
        "Authorization": f"Bearer {os.getenv('MCP_API_KEY')}",
        "X-API-Version": "v2"
    }
)
```

### 使用动态头

```python
# 动态头支持
dynamic_client = oxy.SSEMCPClient(
    name="dynamic_tools",
    sse_url="https://api.example.com/mcp/sse",
    headers={
        "X-Service-Key": "default-key"
    },
    is_dynamic_headers=True,
    is_inherit_headers=True,
    is_keep_alive=False  # 动态头所必需
)
```

### 使用中间件

```python
# 自定义中间件
class MetricsMiddleware:
    async def process_request(self, request):
        request.start_time = time.time()
        return request

    async def process_response(self, response):
        duration = time.time() - response.request.start_time
        print(f"Request took {duration:.2f}s")
        return response

middleware_client = oxy.SSEMCPClient(
    name="monitored_tools",
    sse_url="http://localhost:9000/sse",
    middlewares=[MetricsMiddleware()]
)
```

### 高性能配置

```python
# 为高吞吐量优化
perf_client = oxy.SSEMCPClient(
    name="fast_tools",
    sse_url="http://localhost:9000/sse",
    is_keep_alive=True,      # 持久连接
    timeout=30,              # 快速超时
    semaphore=32,            # 更多并发调用
    retries=1,               # 快速失败
    is_permission_required=False  # 无权限检查
)
```

### 多个远程服务器

```python
oxy_space = [
    oxy.HttpLLM(name="llm", ...),

    # 生产 API
    oxy.SSEMCPClient(
        name="prod_api",
        sse_url="https://prod.example.com/sse",
        headers={"Authorization": f"Bearer {os.getenv('PROD_KEY')}"}
    ),

    # 测试 API
    oxy.SSEMCPClient(
        name="staging_api",
        sse_url="https://staging.example.com/sse",
        headers={"Authorization": f"Bearer {os.getenv('STAGING_KEY')}"}
    ),

    # 本地工具
    oxy.SSEMCPClient(
        name="local_tools",
        sse_url="http://localhost:9000/sse"
    ),

    oxy.ReActAgent(
        name="agent",
        llm_model="llm",
        tools=["prod_api", "staging_api", "local_tools"]
    )
]
```

## 错误处理

### 连接错误

```python
try:
    client = oxy.SSEMCPClient(
        name="unavailable",
        sse_url="http://localhost:9999/sse"  # 服务器未运行
    )
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except Exception as e:
    # "服务器不可用错误"
    print(f"Connection error: {e}")
```

### 身份验证错误

```python
try:
    client = oxy.SSEMCPClient(
        name="secure",
        sse_url="https://api.example.com/sse",
        headers={"Authorization": "Bearer invalid-token"}
    )
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except Exception as e:
    # 身份验证失败
    print(f"Auth error: {e}")
```

### 超时错误

```python
client = oxy.SSEMCPClient(
    name="slow",
    sse_url="http://slow-server.com/sse",
    timeout=5  # 非常短的超时
)
# 超过 5 秒的工具调用将引发超时错误
```

## 性能考虑

### 持久连接 vs 临时连接

|Aspect|Persistent (`is_keep_alive=True`)|Transient (`is_keep_alive=False`)|
|--------|-----------------------------------|-----------------------------------|
| **延迟** | 低（无重连） | 高（每次重连） |
| **吞吐量** | 高 | 较低 |
| **内存** | 较高（持久会话） | 较低（临时会话） |
| **动态头** | 不支持 | 支持 |
| **使用场景** | 多次调用，生产环境 | 单次调用，动态认证 |

### 并发

控制并发工具执行：

```python
oxy.SSEMCPClient(
    name="concurrent",
    sse_url="http://localhost:9000/sse",
    semaphore=64  # 允许 64 个并发工具调用
)
```

## 相关文档

- **[SSEMCPClient 指南](/docs/tools-mcp-sse)** - 主要文档和使用模式
- **[StdioMCPClient API](/oxyapi/tools-mcp-stdio-api)** - 本地进程客户端 API
- **[StreamableMCPClient API](/oxyapi/tools-mcp-streamable-api)** - HTTP 流式客户端 API
- **[BaseMCPClient](/docs/tools-mcp-base)** - 基类文档
- **[MCP 协议](https://modelcontextprotocol.io/)** - 官方 MCP 规范
