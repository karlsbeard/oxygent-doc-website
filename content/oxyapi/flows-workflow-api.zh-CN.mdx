---
title: Workflow API 参考
description: Workflow 流程的完整 API 参考文档，包括构造函数参数和方法
icon: Code
---

## 类概述

```python
from oxygent.oxy.flows import Workflow
from oxygent.schemas import OxyRequest

async def my_workflow_function(oxy_request: OxyRequest) -> str:
    # 您的自定义工作流逻辑
    return "结果"

workflow = Workflow(
    name="my_workflow",
    desc="我的自定义工作流流程",
    func_workflow=my_workflow_function,
    timeout=100,
    llm_model="default_llm"
)
```

## 构造函数参数

### 必需参数

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `name` | str | 必需 | 工作流流程的唯一标识符 |
| `func_workflow` | Callable | 必需 | 要执行的自定义工作流函数 |

### 可选参数

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `desc` | str | "" | 工作流用途的描述 |
| `timeout` | int | 100 | 最大执行时间（秒） |
| `llm_model` | str | "default_llm" | 用于后备操作的 LLM 模型名称 |
| `is_permission_required` | bool | False | 执行前是否需要权限 |
| `category` | str | "flow" | 类别分类 |
| `is_master` | bool | False | 是否为主入口点 |

## 参数详情

### `name`
- **类型**：`str`
- **必需**：是
- **描述**：工作流在多智能体系统中的唯一标识符。通过 `mas.call(callee="workflow_name")` 调用工作流时使用此名称。

**示例：**
```python
Workflow(
    name="data_processing_workflow",
    func_workflow=process_data
)
```

### `func_workflow`
- **类型**：`可选[Callable]`
- **必需**：是（实际使用中）
- **描述**：要执行的自定义工作流函数。必须是接受 `OxyRequest` 并返回字符串的异步函数。

**函数签名：**
```python
async def workflow_function(oxy_request: OxyRequest) -> str:
    """
    Args:
        oxy_request: 包含查询、共享数据和调用方法的请求上下文

    Returns:
        str: 工作流执行的结果
    """
    pass
```

**示例：**
```python
async def my_workflow(oxy_request: OxyRequest) -> str:
    query = oxy_request.get_query()

    # 处理查询
    result = await oxy_request.call(
        callee="processor_agent",
        arguments={"query": query}
    )

    return result.output

Workflow(
    name="processor_flow",
    func_workflow=my_workflow
)
```

### `desc`
- **类型**：`str`
- **默认**：`""`
- **描述**：此工作流功能的可读描述。对文档和调试很有用。

**示例：**
```python
Workflow(
    name="validation_workflow",
    desc="通过多个阶段验证用户输入并返回清理后的数据",
    func_workflow=validate_input
)
```

### `timeout`
- **类型**：`int`
- **默认**：`100`
- **描述**：最大执行时间（秒）。如果工作流超过此时间，将被终止。

**使用指南：**
- 简单工作流：30-60 秒
- 多智能体工作流：100-200 秒
- 复杂处理：300+ 秒

**示例：**
```python
Workflow(
    name="long_running_workflow",
    timeout=300,  # 5 分钟
    func_workflow=complex_analysis
)
```

### `llm_model`
- **类型**：`str`
- **默认**：`"default_llm"`
- **描述**：MAS 中大语言模型组件的名称引用，用于任何后备 LLM 操作。

**示例：**
```python
Workflow(
    name="smart_workflow",
    llm_model="gpt-4",
    func_workflow=intelligent_processing
)
```

### `is_permission_required`
- **类型**：`bool`
- **默认**：`False`
- **描述**：执行此工作流之前是否需要用户权限。

**示例：**
```python
Workflow(
    name="destructive_workflow",
    is_permission_required=True,  # 请求权限
    func_workflow=delete_data
)
```

### `category`
- **类型**：`str`
- **默认**：`"flow"`
- **描述**：工作流的类别分类。从 BaseFlow 继承。

### `is_master`
- **类型**：`bool`
- **默认**：`False`
- **描述**：此工作流是否为多智能体系统的主入口点。

**示例：**
```python
Workflow(
    name="orchestrator_workflow",
    is_master=True,  # 入口点
    func_workflow=orchestrate_system
)
```

## 方法

### `_execute(oxy_request: OxyRequest) -> OxyResponse`

**内部方法** - 由流程框架调用以执行工作流。

**参数:**
- `oxy_request` (OxyRequest): 请求上下文

**返回值:**
- `OxyResponse`: 包含 state=COMPLETED 和来自 func_workflow 输出的响应

**实现：**
```python
async def _execute(self, oxy_request: OxyRequest) -> OxyResponse:
    return OxyResponse(
        state=OxyState.COMPLETED,
        output=await self.func_workflow(oxy_request)
    )
```

**注意：** 这是一个内部方法。用户不应直接调用此方法 - 请使用 `mas.call()` 或 `oxy_request.call()`。

## OxyRequest 上下文

您的工作流函数接收一个包含以下关键方法的 `OxyRequest` 对象：

### `get_query(master_level: bool = False) -> str`

获取当前查询或主级查询。

```python
async def my_workflow(oxy_request: OxyRequest) -> str:
    current_query = oxy_request.get_query()
    master_query = oxy_request.get_query(master_level=True)
    return f"当前: {current_query}, 主级: {master_query}"
```

### `call(callee: str, arguments: dict) -> OxyResponse`

在工作流中调用另一个代理或工具。

```python
async def my_workflow(oxy_request: OxyRequest) -> str:
    response = await oxy_request.call(
        callee="analyzer_agent",
        arguments={"query": "分析这个"}
    )
    return response.output
```

### `shared_data` (dict)

访问工作流中的共享数据。

```python
async def my_workflow(oxy_request: OxyRequest) -> str:
    # 读取共享数据
    state = oxy_request.shared_data.get("state", {})

    # 修改共享数据
    oxy_request.shared_data["counter"] = state.get("counter", 0) + 1

    return f"执行次数: {oxy_request.shared_data['counter']}"
```

## 返回值

### OxyResponse 结构

Workflow 流程返回一个包含以下内容的 `OxyResponse` 对象：

```python
{
    "state": OxyState.COMPLETED,    # 完成状态
    "output": "工作流结果",    # func_workflow 返回的字符串
}
```

## 使用示例

### 简单顺序工作流

```python
async def sequential_workflow(oxy_request: OxyRequest) -> str:
    query = oxy_request.get_query()

    # 步骤 1：分析
    analysis = await oxy_request.call(
        callee="analyzer",
        arguments={"query": query}
    )

    # 步骤 2：基于分析结果进行处理
    result = await oxy_request.call(
        callee="processor",
        arguments={"query": analysis.output}
    )

    return result.output

workflow = Workflow(
    name="seq_flow",
    desc="顺序分析和处理",
    func_workflow=sequential_workflow
)
```

### 条件分支工作流

```python
async def conditional_workflow(oxy_request: OxyRequest) -> str:
    query = oxy_request.get_query()

    if "urgent" in query.lower():
        result = await oxy_request.call(
            callee="urgent_handler",
            arguments={"query": query}
        )
    else:
        result = await oxy_request.call(
            callee="normal_handler",
            arguments={"query": query}
        )

    return result.output

workflow = Workflow(
    name="conditional_flow",
    desc="根据紧急程度路由到不同的处理器",
    func_workflow=conditional_workflow
)
```

### 并行执行工作流

```python
import asyncio

async def parallel_workflow(oxy_request: OxyRequest) -> str:
    query = oxy_request.get_query()

    # 并行执行多个代理
    results = await asyncio.gather(
        oxy_request.call(callee="agent_1", arguments={"query": query}),
        oxy_request.call(callee="agent_2", arguments={"query": query}),
        oxy_request.call(callee="agent_3", arguments={"query": query}),
    )

    # 聚合结果
    combined = " | ".join([r.output for r in results])
    return f"合并结果: {combined}"

workflow = Workflow(
    name="parallel_flow",
    desc="并行执行多个代理",
    func_workflow=parallel_workflow,
    timeout=120  # 为并行执行提供更多时间
)
```

### 迭代优化工作流

```python
async def iterative_workflow(oxy_request: OxyRequest) -> str:
    query = oxy_request.get_query()
    current_result = query

    for iteration in range(3):
        # 精炼结果
        response = await oxy_request.call(
            callee="refiner_agent",
            arguments={"query": current_result}
        )
        current_result = response.output

        # 检查是否满意
        if "FINAL" in current_result:
            break

    return f"精炼结果: {current_result}"

workflow = Workflow(
    name="iterative_flow",
    desc="通过多次迭代精炼结果",
    func_workflow=iterative_workflow
)
```

### 错误处理 Workflow

```python
async def robust_workflow(oxy_request: OxyRequest) -> str:
    query = oxy_request.get_query()

    try:
        # 尝试主要代理
        result = await oxy_request.call(
            callee="primary_agent",
            arguments={"query": query}
        )
        return result.output

    except Exception as primary_error:
        # 降级到备用代理
        try:
            result = await oxy_request.call(
                callee="backup_agent",
                arguments={"query": query}
            )
            return f"降级结果: {result.output}"

        except Exception as backup_error:
            return f"错误: {str(backup_error)}"

workflow = Workflow(
    name="robust_flow",
    desc="Handles errors with fallback agents",
    func_workflow=robust_workflow
)
```

## 最佳实践

### 1. 保持函数异步

Always define workflow functions as `async def`:

```python
# ✅ Correct
async def my_workflow(oxy_request: OxyRequest) -> str:
    result = await oxy_request.call(callee="agent", arguments={})
    return result.output

# ❌ Wrong
def my_workflow(oxy_request: OxyRequest) -> str:  # 非异步
    return "结果"
```

### 2. Use 类型 Hints

始终包含适当的类型提示以确保清晰性:

```python
from oxygent.schemas import OxyRequest

async def my_workflow(oxy_request: OxyRequest) -> str:
    # 类型提示有助于 IDE 自动完成和错误检测
    pass
```

### 3. 优雅地处理错误

在工作流中实施适当的错误处理：

```python
async def safe_workflow(oxy_request: OxyRequest) -> str:
    try:
        result = await oxy_request.call(callee="agent", arguments={})
        return result.output
    except Exception as e:
        return f"发生错误: {str(e)}"
```

### 4. 设置合适的超时时间

根据工作流复杂性调整超时时间：

```python
# 简单工作流
Workflow(name="quick", timeout=30, func_workflow=quick_task)

# 复杂工作流
Workflow(name="complex", timeout=300, func_workflow=complex_task)
```

### 5. 为工作流编写文档

Always provide clear descriptions:

```python
Workflow(
    name="data_pipeline",
    desc="Validates input → Processes data → Generates report",
    func_workflow=pipeline_function
)
```

## 常见模式

### 模式：管道处理

```python
async def pipeline(oxy_request: OxyRequest) -> str:
    data = oxy_request.get_query()

    # 阶段 1：验证
    data = await oxy_request.call(callee="validator", arguments={"query": data})

    # 阶段 2：转换
    data = await oxy_request.call(callee="transformer", arguments={"query": data.output})

    # 阶段 3：完成
    result = await oxy_request.call(callee="finalizer", arguments={"query": data.output})

    return result.output
```

### 模式：扇出/扇入

```python
import asyncio

async def fan_out_in(oxy_request: OxyRequest) -> str:
    query = oxy_request.get_query()

    # 扇出：发送到多个处理器
    results = await asyncio.gather(
        oxy_request.call(callee="proc_1", arguments={"query": query}),
        oxy_request.call(callee="proc_2", arguments={"query": query}),
        oxy_request.call(callee="proc_3", arguments={"query": query}),
    )

    # 扇入：聚合结果
    aggregator_input = "\n".join([r.output for r in results])
    final = await oxy_request.call(
        callee="aggregator",
        arguments={"query": aggregator_input}
    )

    return final.output
```

### 模式：状态机

```python
async def state_machine(oxy_request: OxyRequest) -> str:
    state = oxy_request.shared_data.get("state", "INIT")
    query = oxy_request.get_query()

    if state == "INIT":
        result = await oxy_request.call(callee="initializer", arguments={"query": query})
        oxy_request.shared_data["state"] = "PROCESSING"
    elif state == "PROCESSING":
        result = await oxy_request.call(callee="processor", arguments={"query": query})
        oxy_request.shared_data["state"] = "FINALIZE"
    elif state == "FINALIZE":
        result = await oxy_request.call(callee="finalizer", arguments={"query": query})
        oxy_request.shared_data["state"] = "DONE"

    return f"State: {state} → Result: {result.output}"
```

## 相关 API 参考

- [ParallelFlow API](/oxyapi/flows-parallel-api) - 并行执行流 API
- [PlanAndSolve API](/oxyapi/flows-plan-and-solve-api) - 计划执行流 API
- [Reflexion API](/oxyapi/flows-reflexion-api) - 自我评估流 API
- [Context 文档](/docs/context) - 请求上下文 API
