---
title: StdioMCPClient API 参考
description: StdioMCPClient 类的完整 API 参考文档
icon: Code
---

## 类定义

```python
from oxygent import oxy

# Create a StdioMCPClient instance
client = oxy.StdioMCPClient(
    name="my_mcp_server",
    params={
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"],
        "env": {}
    }
)
```

## 构造函数参数

### 必需参数

|参数|类型|必需|默认值|描述|
|-----------|------|----------|---------|-------------|
| `name` | `str` | **是** | - | MCP 客户端的唯一标识符。代理在其 `tools` 列表中引用此名称 |
| `params` | `dict[str, Any]` | **是** | `{}` | 包含 command、args 和 env 的配置字典 |

### params 字典结构

`params` 字典必须包含：

|键|类型|必需|默认值|描述|
|-----|------|----------|---------|-------------|
| `command` | `str` | **是** | - | 要执行的命令（例如 "npx"、"python"、"node"、"uv"） |
| `args` | `list[str]` | **是** | - | 字符串列表形式的命令行参数 |
| `env` | `dict[str, str]` | 否 | `{}` | 传递给进程的额外环境变量 |

### 从 BaseMCPClient 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `headers` | `dict[str, str]` | `{}` | 额外的 HTTP 头（stdio 传输通常不使用） |
| `is_dynamic_headers` | `bool` | `False` | 启用每个请求的动态头更新 |
| `is_inherit_headers` | `bool` | `False` | 从 OxyRequest 上下文继承头 |
| `is_keep_alive` | `bool` | 配置默认值 | 是否在调用之间保持 MCP 会话活动 |

### 从 BaseTool 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `timeout` | `float` | `60` | 每次工具调用的最大执行时间（秒） |
| `semaphore` | `int` | `16` | 最大并发工具执行数 |
| `retries` | `int` | `2` | 失败时的重试次数 |
| `delay` | `float` | `1.0` | 重试尝试之间的延迟（秒） |
| `is_permission_required` | `bool` | `True` | 代理是否需要权限来调用工具 |
| `is_save_data` | `bool` | `True` | 是否保存执行跟踪 |

### 内部属性

|属性|类型|描述|
|-----------|------|-------------|
| `included_tool_name_list` | `list[str]` | 从 MCP 服务器发现的工具名称列表 |
| `_session` | `ClientSession` | MCP 协议会话（在 `init()` 期间初始化） |
| `_exit_stack` | `AsyncExitStack` | 用于清理的资源管理上下文 |

## 参数详情

### name

- **类型**：`str`
- **必需**：是
- **描述**：此 MCP 客户端在多智能体系统中的唯一标识符。代理在其 `tools` 列表中引用此名称以使用此服务器提供的所有工具。

**示例：**
```python
oxy.StdioMCPClient(
    name="filesystem_tools",  # Agent 将在其 tools 列表中使用 "filesystem_tools"
    ...
)
```

### params

- **类型**: `dict[str, Any]`
- **必需**: 是
- **描述**: 配置字典，指定如何生成和与 MCP 服务器进程通信。

**结构:**
```python
params = {
    "command": "npx",              # 可执行命令
    "args": [                      # 命令行参数
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/workspace"
    ],
    "env": {                       # 可选环境变量
        "DEBUG": "true",
        "API_KEY": "your-key"
    }
}
```

### params.command

- **类型**: `str`
- **必需**: 是
- **描述**: 要执行的命令。常见值包括:
  - `"npx"` - Node Package eXecute，用于 npm 包
  - `"python"` - Python 解释器
  - `"node"` - Node.js 解释器
  - `"uv"` - 快速 Python 包管理器
  - PATH 中的任何其他可执行文件

**特殊处理:**
- 当 `command="npx"` 时，会使用 `shutil.which("npx")` 自动解析为完整路径
- 其他命令按原样使用

**示例:**
```python
# NPX (自动解析)
params={"command": "npx", ...}

# Python
params={"command": "python", ...}

# UV (Python 包管理器)
params={"command": "uv", ...}

# Node.js
params={"command": "node", ...}
```

### params.args

- **类型**: `list[str]`
- **必需**: 是
- **描述**: 传递给命令的命令行参数。每个参数必须是列表中的单独字符串。

**常见模式:**

1. **NPX 与 npm 包:**
```python
args=["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
```

2. **基于目录的执行:**
```python
args=["--directory", "./mcp_servers", "run", "server.py"]
```

3. **直接脚本执行:**
```python
args=["./servers/my_mcp_server.py"]
```

4. **带附加标志:**
```python
args=["--verbose", "--config", "config.json", "server.py"]
```

**验证:**
- 如果 `args` 包含 `["--directory", <dir>, "run", <file>]`，系统会验证:
  - 目录 `<dir>` 必须存在
  - 文件 `<dir>/<file>` 必须存在
  - 验证失败时抛出 `FileNotFoundError`

### params.env

- **类型**: `dict[str, str]`
- **必需**: 否
- **默认值**: `{}`
- **描述**: 传递给 MCP 服务器进程的附加环境变量。这些变量与 `os.environ` 合并，因此服务器可以访问系统和自定义变量。

**示例:**
```python
# 基本环境变量
env={
    "DEBUG": "true",
    "LOG_LEVEL": "info"
}

# API 密钥和秘密
env={
    "API_KEY": os.getenv("MY_API_KEY"),
    "DATABASE_URL": os.getenv("DATABASE_URL")
}

# 自定义配置
env={
    "CACHE_DIR": "/tmp/cache",
    "MAX_WORKERS": "4",
    "TIMEOUT": "30"
}
```

### is_keep_alive

- **类型**: `bool`
- **默认值**: 来自 `Config.get_tool_mcp_is_keep_alive()`
- **描述**: 控制 MCP 会话生命周期:
  - `True`: 在工具调用之间保持进程和会话活动 (更快，持久)
  - `False`: 为每次工具调用创建新进程和会话 (隔离，全新状态)

**何时使用 True (持久):**
- 预期多次工具调用
- 启动成本很高
- 需要状态持久化
- 最常见的用例

**何时使用 False (临时):**
- 单次工具调用
- 需要完全隔离
- 内存清理很重要
- 调试/测试

**示例:**
```python
# 持久连接 (推荐)
oxy.StdioMCPClient(
    name="persistent",
    is_keep_alive=True,
    ...
)

# 临时连接
oxy.StdioMCPClient(
    name="transient",
    is_keep_alive=False,
    ...
)
```

### timeout

- **类型**: `float`
- **默认值**: `60`
- **描述**: 每次工具调用的最大执行时间（秒）。

**使用指南:**
- 快速操作: 10-30 秒
- API 调用: 30-60 秒
- 文件操作: 60-120 秒
- 长时间运行的任务: 120+ 秒

**示例:**
```python
oxy.StdioMCPClient(
    name="slow_server",
    timeout=120,  # 慢操作 2 分钟
    ...
)
```

## 方法

### init()

初始化到 MCP 服务器的 stdio 连接。

```python
async def init(self, is_fetch_tools: bool = True) -> None
```

**参数:**
- `is_fetch_tools` (bool): 初始化后是否自动发现和注册工具。默认: `True`

**行为：**
1. 验证命令路径（使用 `shutil.which()` 解析 `npx`）
2. 如果使用 `--directory` 标志，验证目录结构
3. 确保所需目录存在（如果需要，为文件系统服务器创建）
4. 设置包含命令、参数和合并环境的 `StdioServerParameters`
5. 生成外部进程
6. 建立 stdio 传输（stdin/stdout 管道）
7. 创建并初始化 `ClientSession`
8. 如果 `is_fetch_tools=True`，调用 `list_tools()` 发现可用工具

**错误处理:**
- 如果命令解析为 `None`，抛出 `ValueError`
- 如果所需文件不存在，抛出 `FileNotFoundError`
- 如果初始化失败，抛出包含服务器名称的 `Exception`
- 出错时自动调用 `cleanup()`

**示例（内部使用）：**
```python
# 在初始化期间由 MAS 自动调用
# async with MAS(oxy_space=[client, ...]) as mas:
# # client.init() 在这里被调用
```

### get_server_params()

构建并返回 stdio 服务器参数。

```python
async def get_server_params(self) -> StdioServerParameters
```

**返回：** 包含以下内容的 `StdioServerParameters` 对象:
- `command`: 解析后的命令路径
- `args`: 命令行参数
- `env`: 合并的环境变量

**行为：**
1. 解析命令路径（对 `npx` 进行特殊处理）
2. 验证命令不为 `None`
3. 如果适用，验证目录结构
4. 将 `params.env` 与 `os.environ` 合并
5. 创建 `StdioServerParameters` 实例

**抛出：**
- 如果命令为 `None`，抛出 `ValueError`
- 如果目录验证失败，抛出 `FileNotFoundError`

**示例（内部使用）：**
```python
# 由 init() 和 call_tool() 内部使用
server_params = await self.get_server_params()
```

### call_tool()

在 MCP 服务器上执行工具。

```python
async def call_tool(
    self,
    tool_name: str,
    arguments: dict,
    headers: dict[str, str] = None
) -> Any
```

**参数:**
- `tool_name` (str): 要调用的工具名称
- `arguments` (dict): 工具特定的参数
- `headers` (dict, optional): HTTP 头（stdio 通常不使用）

**返回：** 包含工具执行结果的 MCP 响应对象

**行为：**
1. 通过 `get_server_params()` 获取服务器参数
2. 创建新的 stdio 客户端上下文
3. 建立新会话
4. 初始化 MCP 协议
5. 使用参数调用指定的工具
6. 返回响应

**注意：** 此方法每次创建**新连接**。对于持久连接，`_execute()` 方法使用现有会话。

**示例（内部使用）：**
```python
# 当 is_keep_alive=False 时内部调用
response = await client.call_tool(
    tool_name="read_file",
    arguments={"path": "/tmp/test.txt"}
)
```

### list_tools()

从 MCP 服务器发现并注册工具。

```python
async def list_tools(self) -> None
```

**行为：**
1. 检查 `_session` 是否已初始化
2. 通过 MCP 协议调用 `_session.list_tools()`
3. 调用 `add_tools()` 创建 `MCPTool` 包装器
4. 在 MAS 中注册每个工具

**抛出：**
- 如果服务器未初始化，抛出 `RuntimeError`

**示例（内部使用）：**
```python
# 如果 is_fetch_tools=True，在 init() 期间自动调用
await client.list_tools()
```

### add_tools()

为发现的工具创建 MCPTool 包装器。

```python
def add_tools(self, tools_response) -> None
```

**参数:**
- `tools_response`: 来自 `list_tools()` 的响应，包含工具定义

**行为：**
1. 遍历响应中的工具
2. 为每个工具创建一个 `MCPTool` 实例，包含:
   - 工具名称和描述
   - 对此 MCP 客户端的引用
   - 输入模式
   - 钩子函数（如果已配置）
3. 在 MAS 中注册每个 `MCPTool`
4. 将工具名称添加到 `included_tool_name_list`

**示例（内部使用）：**
```python
# 由 list_tools() 调用
tools_response = await session.list_tools()
client.add_tools(tools_response)
```

### cleanup()

清理 MCP 服务器资源和连接。

```python
async def cleanup(self) -> None
```

**行为：**
1. 获取清理锁以防止并发清理
2. 关闭 `AsyncExitStack`（终止进程和会话）
3. 优雅地处理 `asyncio.CancelledError`
4. 抑制其他异常以防止级联失败
5. 将 `_session` 和 `_stdio_context` 设置为 `None`

**何时调用：**
- MAS 退出时自动调用
- 初始化错误时自动调用
- 如果需要可以手动调用

**示例（通常自动）：**
```python
# 自动清理
async with MAS(oxy_space=[client, ...]) as mas:
    ...
# cleanup() 在这里自动调用
```

## 内部实现细节

### 目录验证

```python
async def _ensure_directories_exist(self, args: list[str]) -> None
```

**行为：**
- 对于文件系统服务器：如果目标目录不存在则创建
- 对于 `--directory` 命令：验证 MCP 工具文件是否存在
- 记录目录创建或失败时的警告

**它处理的示例模式：**
```python
# 文件系统服务器 - 如果需要则创建 /workspace
args = ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]

# 基于目录的服务器 - 验证文件存在
args = ["--directory", "./mcp_servers", "run", "server.py"]
# 确保 ./mcp_servers/server.py 存在
```

## 使用示例

### 基础 NPX 服务器

```python
from oxygent import MAS, oxy
import os

filesystem_client = oxy.StdioMCPClient(
    name="filesystem",
    params={
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"],
        "env": {}
    }
)
```

### 使用 UV 的 Python 服务器

```python
custom_client = oxy.StdioMCPClient(
    name="custom_tools",
    params={
        "command": "uv",
        "args": ["--directory", "./mcp_servers", "run", "my_server.py"],
        "env": {
            "DEBUG": "true",
            "API_KEY": os.getenv("MY_API_KEY")
        }
    },
    timeout=90,
    is_keep_alive=True
)
```

### 使用自定义配置

```python
advanced_client = oxy.StdioMCPClient(
    name="advanced_server",
    params={
        "command": "node",
        "args": ["./custom_mcp_server.js"],
        "env": {
            "NODE_ENV": "production",
            "LOG_LEVEL": "info"
        }
    },
    timeout=120,
    is_keep_alive=True,
    retries=3,
    delay=2.0,
    is_permission_required=False
)
```

### 多个服务器

```python
oxy_space = [
    oxy.HttpLLM(name="llm", ...),

    # 文件系统工具
    oxy.StdioMCPClient(
        name="fs_tools",
        params={
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
        }
    ),

    # Git 工具
    oxy.StdioMCPClient(
        name="git_tools",
        params={
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-git"]
        }
    ),

    # 自定义 Python 工具
    oxy.StdioMCPClient(
        name="custom_tools",
        params={
            "command": "python",
            "args": ["./servers/custom.py"]
        }
    ),

    oxy.ReActAgent(
        name="dev_agent",
        llm_model="llm",
        tools=["fs_tools", "git_tools", "custom_tools"]
    )
]
```

## 错误处理

### 命令未找到

```python
try:
    client = oxy.StdioMCPClient(
        name="server",
        params={"command": "invalid_command", "args": []}
    )
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except ValueError as e:
    # "命令必须是有效字符串且不能为 None。"
    print(f"Command error: {e}")
```

### 文件未找到

```python
try:
    client = oxy.StdioMCPClient(
        name="server",
        params={
            "command": "uv",
            "args": ["--directory", "./mcp_servers", "run", "missing.py"]
        }
    )
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except FileNotFoundError as e:
    # "./mcp_servers/missing.py 不存在。"
    print(f"File error: {e}")
```

### 初始化失败

```python
try:
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except Exception as e:
    # "服务器 <name> 错误"
    print(f"Server initialization failed: {e}")
```

## 相关文档

- **[StdioMCPClient 指南](/docs/tools-mcp-stdio)** - 主要文档和使用模式
- **[SSEMCPClient API](/oxyapi/tools-mcp-sse-api)** - HTTP SSE 客户端 API
- **[StreamableMCPClient API](/oxyapi/tools-mcp-streamable-api)** - HTTP 流式客户端 API
- **[BaseMCPClient](/docs/tools-mcp-base)** - 基类文档
- **[MCP 协议](https://modelcontextprotocol.io/)** - 官方 MCP 规范
