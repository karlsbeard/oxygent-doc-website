---
title: StdioMCPClient API 参考
description: StdioMCPClient 类的完整 API 参考文档
icon: Code
---

## 类定义

```python
from oxygent import oxy

# Create a StdioMCPClient instance
client = oxy.StdioMCPClient(
    name="my_mcp_server",
    params={
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"],
        "env": {}
    }
)
```

## 构造函数参数

### 必需参数

|参数|类型|必需|默认值|描述|
|-----------|------|----------|---------|-------------|
| `name` | `str` | **是** | - | MCP 客户端的唯一标识符。代理在其 `tools` 列表中引用此名称 |
| `params` | `dict[str, Any]` | **是** | `{}` | 包含 command、args 和 env 的配置字典 |

### params 字典结构

`params` 字典必须包含：

|键|类型|必需|默认值|描述|
|-----|------|----------|---------|-------------|
| `command` | `str` | **是** | - | 要执行的命令（例如 "npx"、"python"、"node"、"uv"） |
| `args` | `list[str]` | **是** | - | 字符串列表形式的命令行参数 |
| `env` | `dict[str, str]` | 否 | `{}` | 传递给进程的额外环境变量 |

### 从 BaseMCPClient 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `headers` | `dict[str, str]` | `{}` | 额外的 HTTP 头（stdio 传输通常不使用） |
| `is_dynamic_headers` | `bool` | `False` | 启用每个请求的动态头更新 |
| `is_inherit_headers` | `bool` | `False` | 从 OxyRequest 上下文继承头 |
| `is_keep_alive` | `bool` | 配置默认值 | 是否在调用之间保持 MCP 会话活动 |

### 从 BaseTool 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `timeout` | `float` | `60` | 每次工具调用的最大执行时间（秒） |
| `semaphore` | `int` | `16` | 最大并发工具执行数 |
| `retries` | `int` | `2` | 失败时的重试次数 |
| `delay` | `float` | `1.0` | 重试尝试之间的延迟（秒） |
| `is_permission_required` | `bool` | `True` | 代理是否需要权限来调用工具 |
| `is_save_data` | `bool` | `True` | 是否保存执行跟踪 |

### 内部属性

|属性|类型|描述|
|-----------|------|-------------|
| `included_tool_name_list` | `list[str]` | 从 MCP 服务器发现的工具名称列表 |
| `_session` | `ClientSession` | MCP 协议会话（在 `init()` 期间初始化） |
| `_exit_stack` | `AsyncExitStack` | 用于清理的资源管理上下文 |

## 参数详情

### name

- **类型**：`str`
- **必需**：是
- **描述**：此 MCP 客户端在多智能体系统中的唯一标识符。代理在其 `tools` 列表中引用此名称以使用此服务器提供的所有工具。

**示例：**
```python
oxy.StdioMCPClient(
    name="filesystem_tools",  # Agents will use "filesystem_tools" in their tools list
    ...
)
```

### params

- **Type**: `dict[str, Any]`
- **必需**: Yes
- **Description**: Configuration dictionary that specifies how to spawn 和 communicate 包含 the MCP server process.

**Structure:**
```python
params = {
    "command": "npx",              # Executable command
    "args": [                      # Command-line arguments
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/workspace"
    ],
    "env": {                       # Optional environment variables
        "DEBUG": "true",
        "API_KEY": "your-key"
    }
}
```

### params.command

- **Type**: `str`
- **必需**: Yes
- **Description**: The comm和 to execute. Common values include:
  - `"npx"` - Node Package eXecute for npm packages
  - `"python"` - Python interpreter
  - `"node"` - Node.js interpreter
  - `"uv"` - Fast Python package manager
  - Any other executable in PATH

**Special Handling:**
- When `comm和="npx"`, it's automatically resolved to the full path using `shutil.which("npx")`
- Other comm和s are used as-is

**Examples:**
```python
# NPX (automatically resolved)
params={"command": "npx", ...}

# Python
params={"command": "python", ...}

# UV (Python package manager)
params={"command": "uv", ...}

# 否de.js
params={"command": "node", ...}
```

### params.args

- **Type**: `list[str]`
- **必需**: Yes
- **Description**: Comm和-line arguments passed to the comm和. Each argument must be a separate string in the list.

**常见模式:**

1. **NPX 包含 npm package:**
```python
args=["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
```

2. **Directory-based execution:**
```python
args=["--directory", "./mcp_servers", "run", "server.py"]
```

3. **Direct script execution:**
```python
args=["./servers/my_mcp_server.py"]
```

4. **With additional flags:**
```python
args=["--verbose", "--config", "config.json", "server.py"]
```

**Validation:**
- If `args` contains `["--directory", <dir>, "run", <file>]`, the system validates:
  - The directory `<dir>` must exist
  - The file `<dir>/<file>` must exist
  - Raises `FileNotFoundError` if validation fails

### params.env

- **Type**: `dict[str, str]`
- **必需**: No
- **默认**: `{}`
- **Description**: Additional environment variables to pass to the MCP server process. These are merged 包含 `os.environ`, so the server has access to both system 和 custom variables.

**Examples:**
```python
# Basic environment variables
env={
    "DEBUG": "true",
    "LOG_LEVEL": "info"
}

# API keys and secrets
env={
    "API_KEY": os.getenv("MY_API_KEY"),
    "DATABASE_URL": os.getenv("DATABASE_URL")
}

# Custom configuration
env={
    "CACHE_DIR": "/tmp/cache",
    "MAX_WORKERS": "4",
    "TIMEOUT": "30"
}
```

### is_keep_alive

- **Type**: `bool`
- **默认**: From `Config.get_tool_mcp_is_keep_alive()`
- **Description**: Controls MCP session lifecycle:
  - `True`: Keep process 和 session alive between tool calls (faster, persistent)
  - `False`: Create new process 和 session for each tool call (isolated, fresh state)

**When to use True (persistent):**
- Multiple tool calls expected
- Startup cost is significant
- State persistence is desired
- Most common use case

**When to use False (transient):**
- Single tool call
- Complete isolation needed
- Memory cleanup important
- Debugging/testing

**Example:**
```python
# Persistent connection (recommended)
oxy.StdioMCPClient(
    name="persistent",
    is_keep_alive=True,
    ...
)

# Transient connection
oxy.StdioMCPClient(
    name="transient",
    is_keep_alive=False,
    ...
)
```

### timeout

- **Type**: `float`
- **默认**: `60`
- **Description**: Maximum execution time for each tool call in seconds.

**使用指南:**
- Fast operations: 10-30 seconds
- API calls: 30-60 seconds
- File operations: 60-120 seconds
- Long-running tasks: 120+ seconds

**Example:**
```python
oxy.StdioMCPClient(
    name="slow_server",
    timeout=120,  # 2 minutes for slow operations
    ...
)
```

## 方法

### init()

初始化到 MCP 服务器的 stdio 连接。

```python
async def init(self, is_fetch_tools: bool = True) -> None
```

**参数:**
- `is_fetch_tools` (bool): 初始化后是否自动发现和注册工具。默认: `True`

**行为：**
1. 验证命令路径（使用 `shutil.which()` 解析 `npx`）
2. 如果使用 `--directory` 标志，验证目录结构
3. 确保所需目录存在（如果需要，为文件系统服务器创建）
4. 设置包含命令、参数和合并环境的 `StdioServerParameters`
5. 生成外部进程
6. 建立 stdio 传输（stdin/stdout 管道）
7. 创建并初始化 `ClientSession`
8. 如果 `is_fetch_tools=True`，调用 `list_tools()` 发现可用工具

**错误处理:**
- 如果命令解析为 `None`，抛出 `ValueError`
- 如果所需文件不存在，抛出 `FileNotFoundError`
- 如果初始化失败，抛出包含服务器名称的 `Exception`
- 出错时自动调用 `cleanup()`

**示例（内部使用）：**
```python
# Called automatically by MAS during initialization
# async with MAS(oxy_space=[client, ...]) as mas:
# # client.init() is called here
```

### get_server_params()

构建并返回 stdio 服务器参数。

```python
async def get_server_params(self) -> StdioServerParameters
```

**返回：** 包含以下内容的 `StdioServerParameters` 对象:
- `command`: 解析后的命令路径
- `args`: 命令行参数
- `env`: 合并的环境变量

**行为：**
1. 解析命令路径（对 `npx` 进行特殊处理）
2. 验证命令不为 `None`
3. 如果适用，验证目录结构
4. 将 `params.env` 与 `os.environ` 合并
5. 创建 `StdioServerParameters` 实例

**抛出：**
- 如果命令为 `None`，抛出 `ValueError`
- 如果目录验证失败，抛出 `FileNotFoundError`

**示例（内部使用）：**
```python
# Used internally by init() and call_tool()
server_params = await self.get_server_params()
```

### call_tool()

在 MCP 服务器上执行工具。

```python
async def call_tool(
    self,
    tool_name: str,
    arguments: dict,
    headers: dict[str, str] = None
) -> Any
```

**参数:**
- `tool_name` (str): 要调用的工具名称
- `arguments` (dict): 工具特定的参数
- `headers` (dict, optional): HTTP 头（stdio 通常不使用）

**返回：** 包含工具执行结果的 MCP 响应对象

**行为：**
1. 通过 `get_server_params()` 获取服务器参数
2. 创建新的 stdio 客户端上下文
3. 建立新会话
4. 初始化 MCP 协议
5. 使用参数调用指定的工具
6. 返回响应

**注意：** 此方法每次创建**新连接**。对于持久连接，`_execute()` 方法使用现有会话。

**示例（内部使用）：**
```python
# Called internally when is_keep_alive=False
response = await client.call_tool(
    tool_name="read_file",
    arguments={"path": "/tmp/test.txt"}
)
```

### list_tools()

从 MCP 服务器发现并注册工具。

```python
async def list_tools(self) -> None
```

**行为：**
1. 检查 `_session` 是否已初始化
2. 通过 MCP 协议调用 `_session.list_tools()`
3. 调用 `add_tools()` 创建 `MCPTool` 包装器
4. 在 MAS 中注册每个工具

**抛出：**
- 如果服务器未初始化，抛出 `RuntimeError`

**示例（内部使用）：**
```python
# Called automatically during init() if is_fetch_tools=True
await client.list_tools()
```

### add_tools()

为发现的工具创建 MCPTool 包装器。

```python
def add_tools(self, tools_response) -> None
```

**参数:**
- `tools_response`: 来自 `list_tools()` 的响应，包含工具定义

**行为：**
1. 遍历响应中的工具
2. 为每个工具创建一个 `MCPTool` 实例，包含:
   - 工具名称和描述
   - 对此 MCP 客户端的引用
   - 输入模式
   - 钩子函数（如果已配置）
3. 在 MAS 中注册每个 `MCPTool`
4. 将工具名称添加到 `included_tool_name_list`

**示例（内部使用）：**
```python
# Called by list_tools()
tools_response = await session.list_tools()
client.add_tools(tools_response)
```

### cleanup()

清理 MCP 服务器资源和连接。

```python
async def cleanup(self) -> None
```

**行为：**
1. 获取清理锁以防止并发清理
2. 关闭 `AsyncExitStack`（终止进程和会话）
3. 优雅地处理 `asyncio.CancelledError`
4. 抑制其他异常以防止级联失败
5. 将 `_session` 和 `_stdio_context` 设置为 `None`

**何时调用：**
- MAS 退出时自动调用
- 初始化错误时自动调用
- 如果需要可以手动调用

**示例（通常自动）：**
```python
# Automatic cleanup
async with MAS(oxy_space=[client, ...]) as mas:
    ...
# cleanup() called here automatically
```

## 内部实现细节

### 目录验证

```python
async def _ensure_directories_exist(self, args: list[str]) -> None
```

**行为：**
- 对于文件系统服务器：如果目标目录不存在则创建
- 对于 `--directory` 命令：验证 MCP 工具文件是否存在
- 记录目录创建或失败时的警告

**它处理的示例模式：**
```python
# Filesystem server - creates /workspace if needed
args = ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]

# Directory-based server - validates file exists
args = ["--directory", "./mcp_servers", "run", "server.py"]
# Ensures ./mcp_servers/server.py exists
```

## 使用示例

### 基础 NPX 服务器

```python
from oxygent import MAS, oxy
import os

filesystem_client = oxy.StdioMCPClient(
    name="filesystem",
    params={
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"],
        "env": {}
    }
)
```

### 使用 UV 的 Python 服务器

```python
custom_client = oxy.StdioMCPClient(
    name="custom_tools",
    params={
        "command": "uv",
        "args": ["--directory", "./mcp_servers", "run", "my_server.py"],
        "env": {
            "DEBUG": "true",
            "API_KEY": os.getenv("MY_API_KEY")
        }
    },
    timeout=90,
    is_keep_alive=True
)
```

### 使用自定义配置

```python
advanced_client = oxy.StdioMCPClient(
    name="advanced_server",
    params={
        "command": "node",
        "args": ["./custom_mcp_server.js"],
        "env": {
            "NODE_ENV": "production",
            "LOG_LEVEL": "info"
        }
    },
    timeout=120,
    is_keep_alive=True,
    retries=3,
    delay=2.0,
    is_permission_required=False
)
```

### 多个服务器

```python
oxy_space = [
    oxy.HttpLLM(name="llm", ...),

    # Filesystem tools
    oxy.StdioMCPClient(
        name="fs_tools",
        params={
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
        }
    ),

    # Git tools
    oxy.StdioMCPClient(
        name="git_tools",
        params={
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-git"]
        }
    ),

    # Custom Python tools
    oxy.StdioMCPClient(
        name="custom_tools",
        params={
            "command": "python",
            "args": ["./servers/custom.py"]
        }
    ),

    oxy.ReActAgent(
        name="dev_agent",
        llm_model="llm",
        tools=["fs_tools", "git_tools", "custom_tools"]
    )
]
```

## 错误处理

### 命令未找到

```python
try:
    client = oxy.StdioMCPClient(
        name="server",
        params={"command": "invalid_command", "args": []}
    )
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except ValueError as e:
    # "The command must be a valid string and cannot be None."
    print(f"Command error: {e}")
```

### 文件未找到

```python
try:
    client = oxy.StdioMCPClient(
        name="server",
        params={
            "command": "uv",
            "args": ["--directory", "./mcp_servers", "run", "missing.py"]
        }
    )
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except FileNotFoundError as e:
    # "./mcp_servers/missing.py does not exist."
    print(f"File error: {e}")
```

### 初始化失败

```python
try:
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except Exception as e:
    # "Server <name> error"
    print(f"Server initialization failed: {e}")
```

## 相关文档

- **[StdioMCPClient 指南](/docs/tools-mcp-stdio)** - 主要文档和使用模式
- **[SSEMCPClient API](/oxyapi/tools-mcp-sse-api)** - HTTP SSE 客户端 API
- **[StreamableMCPClient API](/oxyapi/tools-mcp-streamable-api)** - HTTP 流式客户端 API
- **[BaseMCPClient](/docs/tools-mcp-base)** - 基类文档
- **[MCP 协议](https://modelcontextprotocol.io/)** - 官方 MCP 规范
