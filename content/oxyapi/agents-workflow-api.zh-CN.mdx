---
title: WorkflowAgent API 参考
description: WorkflowAgent 类的完整 API 文档
icon: Code
---

## 类定义

```python
from oxygent import oxy

agent = oxy.WorkflowAgent(
    name="workflow_agent",
    func_workflow=my_workflow_function,
    desc="代理功能描述",
    llm_model="default_llm",
    sub_agents=["agent1", "agent2"],
    tools=["tool1", "tool2"],
    is_master=False,
    timeout=60,
)
```

## 构造函数参数

### 必需参数

|参数|类型|必需|默认值|描述|
|-----------|------|----------|---------|-------------|
| `name` | `str` | **是** | - | 在 MAS 系统中此代理的唯一标识符 |
| `func_workflow` | `Callable[[OxyRequest], Awaitable[Any]]` | **是** | `None` | 实现工作流逻辑的异步函数。接收 OxyRequest 并返回输出 |

### 核心配置

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `desc` | `str` | `""` | 当此代理作为工具调用时显示的人类可读描述 |
| `llm_model` | `str` | 来自 `Config` | 用于子代理调用的 LLM 模型标识符（使用 sub_agents 时必需） |
| `prompt` | `str` | 来自 `Config` | 代理行为的系统提示模板（继承但对 WorkflowAgent 不太有用） |
| `additional_prompt` | `str` | `""` | 附加到默认提示的额外提示文本 |

### 代理编排

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `sub_agents` | `list[str]` | `[]` | 此工作流可以委托的子代理名称 |
| `tools` | `list[str]` | `[]` | 此工作流可用的工具名称（MCP 工具、FunctionHubs 等） |
| `except_tools` | `list[str]` | `[]` | 明确禁止此代理使用的工具名称 |
| `is_master` | `bool` | `False` | 此代理是否为 MAS 的主编排器 |

### 内存和上下文管理

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `short_memory_size` | `int` | 来自 `Config` | 在短期内存中保留的对话轮数 |
| `is_retain_master_short_memory` | `bool` | `False` | 是否在工作流中保留主级别（用户级别）内存上下文 |
| `is_attachment_processing_enabled` | `bool` | `True` | 是否将附件注入查询文本 |
| `is_multimodal_supported` | `bool` | `False` | 是否支持多模态输入（图像、文件等） |

### 工具检索（高级）

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `is_sourcing_tools` | `bool` | `False` | 启用动态工具检索而不是静态工具列表 |
| `top_k_tools` | `int` | `10` | 启用源检索时要检索的最大工具数量 |
| `is_retain_subagent_in_toolset` | `bool` | `False` | 在工具集中保留子代理（确保它们始终可用） |
| `is_retrieve_even_if_tools_scarce` | `bool` | `True` | 即使代理工具少于 k 个也执行检索 |
| `intent_understanding_agent` | `str` | `None` | 在工具检索期间用于查询重写的代理名称 |

### 执行控制

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `timeout` | `float` | `3600` | 最大执行时间（秒）（默认：1 小时） |
| `semaphore` | `int` | `16` | 允许的最大并发执行数 |
| `retries` | `int` | `2` | 失败时的重试次数 |
| `delay` | `float` | `1.0` | 重试间隔时间（秒） |
| `team_size` | `int` | `1` | 团队执行模式的并行实例数 |

### 消息和日志

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `is_send_tool_call` | `bool` | 来自 `Config` | 是否向用户发送工具调用消息 |
| `is_send_observation` | `bool` | 来自 `Config` | 是否向用户发送观察/结果消息 |
| `is_send_answer` | `bool` | 来自 `Config` | 是否向用户发送最终答案消息 |
| `is_detailed_tool_call` | `bool` | 来自 `Config` | 是否在日志中显示详细的工具调用信息 |
| `is_detailed_observation` | `bool` | 来自 `Config` | 是否在日志中显示详细的观察信息 |

### 高级配置

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `input_schema` | `dict[str, Any]` | 来自 `Config` | 用于验证的输入模式定义 |
| `is_permission_required` | `bool` | `True` | 此代理是否需要执行权限 |
| `is_save_data` | `bool` | `True` | 是否将执行跟踪保存到 Elasticsearch |
| `friendly_error_text` | `str` | `None` | 失败时显示的用户友好错误消息 |
| `category` | `str` | `"agent"` | 类别分类（自动设置） |

### 函数钩子（高级）

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `func_process_input` | `Callable` | Identity | 执行前处理输入的异步函数 |
| `func_process_output` | `Callable` | Identity | 执行后处理输出的异步函数 |
| `func_format_input` | `Callable` | Identity | 为被调用者格式化输入的异步函数 |
| `func_format_output` | `Callable` | Identity | 为调用者格式化输出的异步函数 |
| `func_interceptor` | `Callable` | `None` | 拦截和修改执行的异步函数 |

## 方法

### _execute()

执行工作流函数的内部方法。用户不直接调用。

```python
async def _execute(self, oxy_request: OxyRequest) -> OxyResponse
```

**参数:**
- `oxy_request` (OxyRequest): 包含查询、内存和上下文的请求对象

**返回值:**
- `OxyResponse`: 包含 `state=COMPLETED` 和工作流输出的响应对象

**实现:**
```python
return OxyResponse(
    state=OxyState.COMPLETED,
    output=await self.func_workflow(oxy_request)
)
```

## 工作流函数签名

`func_workflow` 参数必须是具有以下签名的异步函数：

```python
async def workflow_function(oxy_request: OxyRequest) -> Any:
    # 您的工作流逻辑在这里
    return result
```

### OxyRequest API

`OxyRequest` 对象提供以下方法供工作流使用：

#### 内存访问

```python
# 获取本地代理的短期内存
local_memory = oxy_request.get_short_memory()

# 获取主代理的短期内存（用户级别历史）
master_memory = oxy_request.get_short_memory(master_level=True)
```

**返回类型:** `list[Message]` - 对话消息列表

#### 查询访问

```python
# 获取当前查询
query = oxy_request.get_query()

# 获取主级别查询（原始用户查询）
master_query = oxy_request.get_query(master_level=True)
```

**返回类型:** `str` - 查询字符串

#### 调用组件

```python
# 调用子代理
response = await oxy_request.call(
    callee="agent_name",
    arguments={"query": "什么是..."}
)

# 调用工具
response = await oxy_request.call(
    callee="tool_name",
    arguments={"param1": "value1"}
)

# 直接调用 LLM
response = await oxy_request.call(
    callee="llm_name",
    arguments={
        "messages": [
            {"role": "system", "content": "你是..."},
            {"role": "user", "content": "你好"}
        ],
        "llm_params": {"temperature": 0.7}
    }
)
```

**参数:**
- `callee` (str): 要调用的代理、工具或 LLM 的名称
- `arguments` (dict): 传递给被调用者的参数

**返回类型:** `OxyResponse` - 带有 `.output` 字段的响应对象

#### 发送消息

```python
# 向用户发送中间消息
await oxy_request.send_message({
    "type": "status",
    "content": "正在处理第 2 步，共 5 步..."
})
```

**参数:**
- `message` (dict): 包含 `type` 和 `content` 字段的消息字典

## 使用示例

### 基础工作流

```python
async def simple_workflow(oxy_request: OxyRequest):
    query = oxy_request.get_query()
    response = await oxy_request.call(
        callee="time_tools",
        arguments={"timezone": "UTC"}
    )
    return f"时间: {response.output}"

agent = oxy.WorkflowAgent(
    name="time_agent",
    desc="查询当前时间",
    func_workflow=simple_workflow,
    tools=["time_tools"]
)
```

### 多步骤工作流

```python
async def complex_workflow(oxy_request: OxyRequest):
    # 步骤 1：获取上下文
    history = oxy_request.get_short_memory()
    query = oxy_request.get_query()

    # 步骤 2：调用代理
    await oxy_request.send_message({"type": "status", "content": "分析中..."})
    agent_result = await oxy_request.call(
        callee="chat_agent",
        arguments={"query": query}
    )

    # 步骤 3：调用 LLM 进行分析
    llm_result = await oxy_request.call(
        callee="default_llm",
        arguments={
            "messages": [
                {"role": "user", "content": f"总结: {agent_result.output}"}
            ]
        }
    )

    # 步骤 4：调用工具
    tool_result = await oxy_request.call(
        callee="save_to_file",
        arguments={"content": llm_result.output}
    )

    return f"已保存: {tool_result.output}"

agent = oxy.WorkflowAgent(
    name="master_workflow",
    is_master=True,
    func_workflow=complex_workflow,
    sub_agents=["chat_agent"],
    tools=["save_to_file"],
    llm_model="default_llm",
    timeout=120
)
```

### 条件工作流

```python
async def conditional_workflow(oxy_request: OxyRequest):
    query = oxy_request.get_query()

    # 基于查询内容进行分支
    if "urgent" in query.lower():
        response = await oxy_request.call(
            callee="priority_agent",
            arguments={"query": query, "priority": "high"}
        )
    else:
        response = await oxy_request.call(
            callee="standard_agent",
            arguments={"query": query}
        )

    return response.output

agent = oxy.WorkflowAgent(
    name="router_agent",
    func_workflow=conditional_workflow,
    sub_agents=["priority_agent", "standard_agent"]
)
```

### 使用内存的工作流

```python
async def memory_workflow(oxy_request: OxyRequest):
    # 访问本地和主内存
    local_history = oxy_request.get_short_memory()
    master_history = oxy_request.get_short_memory(master_level=True)

    # 使用上下文进行决策
    if len(master_history) > 5:
        return "你聊了很多！需要总结吗？"

    query = oxy_request.get_query()
    response = await oxy_request.call(
        callee="chat_agent",
        arguments={"query": query}
    )

    return response.output

agent = oxy.WorkflowAgent(
    name="context_aware_agent",
    func_workflow=memory_workflow,
    sub_agents=["chat_agent"],
    is_retain_master_short_memory=True,
    short_memory_size=10
)
```

## 类型定义

### OxyRequest

```python
class OxyRequest:
    arguments: dict                    # 节点级参数
    shared_data: dict                  # 请求级共享数据
    group_data: dict                   # 会话组数据
    caller_category: str               # 调用者类别（"user"、"agent" 等）
    from_trace_id: str                 # 父跟踪 ID
    root_trace_ids: list[str]          # 跟踪 ID 层次结构

    def get_short_memory(self, master_level: bool = False) -> list[Message]
    def get_query(self, master_level: bool = False) -> str
    async def call(self, callee: str, arguments: dict) -> OxyResponse
    async def send_message(self, message: dict) -> None
```

### OxyResponse

```python
class OxyResponse:
    state: OxyState                    # COMPLETED、ERROR 等
    output: Any                        # 工作流执行结果
    error_msg: str                     # 状态为 ERROR 时的错误消息
```

### OxyState

```python
class OxyState(str, Enum):
    COMPLETED = "completed"            # 成功完成
    ERROR = "error"                    # 执行错误
    REJECT = "reject"                  # 权限被拒绝
    TIMEOUT = "timeout"                # 执行超时
```

## 相关文档

- **[WorkflowAgent 指南](/docs/agents-workflow)** - 主要文档和使用模式
- **[ReActAgent API](/oxyapi/agents-react-api)** - 推理和行动代理的 API
- **[OxyRequest 和上下文](/docs/context)** - 详细的上下文 API 文档
- **[四作用域系统](/docs/four-scope)** - 理解数据作用域
- **[配置](/docs/configuration)** - 全局配置选项
