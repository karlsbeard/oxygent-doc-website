---
title: StreamableMCPClient API 参考
description: StreamableMCPClient 类的完整 API 参考文档
icon: Code
---

## 类定义

```python
from oxygent import oxy

# Create a StreamableMCPClient instance
client = oxy.StreamableMCPClient(
    name="streaming_tools",
    server_url="http://127.0.0.1:8000/mcp",
    headers={"Authorization": "Bearer token"},
    middlewares=[]
)
```

## 构造函数参数

### 必需参数

|参数|类型|必需|默认值|描述|
|-----------|------|----------|---------|-------------|
| `name` | `str` | **是** | - | MCP 客户端的唯一标识符。代理在其 `tools` 列表中引用此名称 |
| `server_url` | `AnyUrl` | **是** | `""` | 流式 MCP 服务器的 HTTP(S) 端点 URL |

### 可选参数

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `middlewares` | `list[Any]` | `[]` | 用于流处理的客户端 MCP 中间件列表 |

### 从 BaseMCPClient 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `headers` | `dict[str, str]` | `{}` | 随所有请求发送的 HTTP 头 |
| `is_dynamic_headers` | `bool` | `False` | 启用每个请求的动态头更新 |
| `is_inherit_headers` | `bool` | `False` | 从 OxyRequest._headers 继承头 |
| `is_keep_alive` | `bool` | 配置默认值 | 在调用之间保持 HTTP 连接活动 |

### 从 BaseTool 继承

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `timeout` | `float` | `60` | 每次工具调用的最大执行时间（秒） |
| `semaphore` | `int` | `16` | 最大并发工具执行数 |
| `retries` | `int` | `2` | 失败时的重试次数 |
| `delay` | `float` | `1.0` | 重试尝试之间的延迟（秒） |
| `is_permission_required` | `bool` | `True` | 代理是否需要权限来调用工具 |
| `is_save_data` | `bool` | `True` | 是否保存执行跟踪 |

### 内部属性

|属性|类型|描述|
|-----------|------|-------------|
| `included_tool_name_list` | `list[str]` | 从 MCP 服务器发现的工具名称列表 |
| `_session` | `ClientSession` | MCP 协议会话（在 `init()` 期间初始化） |
| `_http_transport` | `tuple` | HTTP 传输元组（read、write、cancel）用于持久连接 |
| `_exit_stack` | `AsyncExitStack` | 用于清理的资源管理上下文 |

## 参数详情

### name

- **Type**: `str`
- **必需**: Yes
- **Description**: Unique identifier for this streamable MCP client 在多智能体系统中. Agents reference this name in their `tools` list to use all tools provided by this streaming server.

**Example:**
```python
oxy.StreamableMCPClient(
    name="streaming_api_tools",  # Agents use "streaming_api_tools" in tools list
    ...
)
```

### server_url

- **Type**: `AnyUrl` (Pydantic URL type)
- **必需**: Yes
- **Description**: The HTTP(S) URL endpoint where the streamable MCP server is hosted. This URL points to the server's streaming endpoint.

**Format:**
- Must be a valid URL
- Typically ends 包含 `/mcp` or similar path
- Can be HTTP (local/dev) or HTTPS (production)
- Different from SSE endpoint (no `/sse` suffix)

**Examples:**
```python
# Local development
server_url="http://localhost:8000/mcp"
server_url="http://127.0.0.1:3000/api/mcp"

# Production
server_url="https://api.example.com/mcp"
server_url="https://streaming.myapp.com/mcp/v1"
```

**URL Processing:**
The URL is processed through `build_url()` utility which:
- Ensures proper formatting
- H和les trailing slashes
- Validates URL structure

### headers

- **Type**: `dict[str, str]`
- **默认**: `{}`
- **Description**: HTTP headers included in all streaming requests. Commonly used for authentication, versioning, 和 custom metadata.

**Common Use Cases:**

1. **Authentication:**
```python
headers={
    "Authorization": "Bearer your-streaming-token",
    "X-API-Key": os.getenv("STREAMING_API_KEY")
}
```

2. **API Configuration:**
```python
headers={
    "X-API-Version": "v2",
    "Accept": "application/json",
    "X-Stream-Mode": "bidirectional"
}
```

3. **Client Identification:**
```python
headers={
    "X-Client-ID": "oxygent-streaming",
    "X-Application": "my-app",
    "User-Agent": "OxyGent/1.0"
}
```

**Behavior:**
- Headers sent 包含 every HTTP streaming connection
- Can be overridden per-request if `is_dynamic_headers=True`
- `host` header automatically removed if inherited

### is_dynamic_headers

- **Type**: `bool`
- **默认**: `False`
- **Description**: Enable dynamic header updates on a per-request basis. When enabled, headers can be provided in tool calls 和 will override/merge 包含 base headers.

**Requirements:**
- Must set `is_keep_alive=False` for dynamic headers
- Creates new HTTP connection for each tool call

**Example:**
```python
# Enable dynamic headers
oxy.StreamableMCPClient(
    name="dynamic_streaming",
    server_url="http://localhost:8000/mcp",
    headers={
        "X-Service-Key": "default"  # Base headers
    },
    is_dynamic_headers=True,
    is_keep_alive=False  # Required
)

# Provide dynamic headers in tool call
await oxy_request.call(
    callee="tool_name",
    arguments={"param": "value"},
    headers={  # Override/merge with base
        "X-User-ID": "user123",
        "X-Request-ID": "req456"
    }
)
```

### is_inherit_headers

- **Type**: `bool`
- **默认**: `False`
- **Description**: Inherit headers from the OxyRequest context (`_headers` field). Useful for propagating headers through the call chain.

**Behavior:**
- Reads `oxy_request.shared_data.get("_headers", {})` if `is_inherit_headers=True`
- Removes `host` header automatically
- Merges: `base headers | inherited headers | dynamic headers`

**Example:**
```python
oxy.StreamableMCPClient(
    name="inherit_streaming",
    server_url="http://localhost:8000/mcp",
    is_dynamic_headers=True,
    is_inherit_headers=True,  # Inherit from context
    is_keep_alive=False
)

# Upstream provides headers
await mas.call(
    callee="agent",
    arguments={
        "messages": [...],
        "_headers": {  # Inherited by streaming client
            "X-Trace-ID": "trace123",
            "X-Session": "session456"
        }
    }
)
```

### is_keep_alive

- **Type**: `bool`
- **默认**: From `Config.get_tool_mcp_is_keep_alive()`
- **Description**: Controls HTTP streaming connection lifecycle.

**True (Persistent Connection):**
- Single HTTP connection during `init()`
- Connection reused for all tool calls
- Lower latency (no reconnection overhead)
- Tools discovered once at startup
- Cannot use dynamic headers
- **Recommended for production**

**False (Transient Connection):**
- New HTTP connection per tool call
- Fresh state every time
- 必需 for dynamic headers
- Higher latency (reconnection cost)
- Tools rediscovered each time

**Examples:**
```python
# Persistent (recommended)
oxy.StreamableMCPClient(
    name="persistent",
    server_url="http://localhost:8000/mcp",
    is_keep_alive=True  # Default
)

# Transient (for dynamic headers)
oxy.StreamableMCPClient(
    name="transient",
    server_url="http://localhost:8000/mcp",
    is_dynamic_headers=True,
    is_keep_alive=False  # Required
)
```

### middlewares

- **Type**: `list[Any]`
- **默认**: `[]`
- **Description**: List of client-side middleware 对象s for processing streaming requests 和 responses. Middlewares intercept 和 modify stream data.

**Middleware Interface:**
Middleware 对象s should implement methods for stream processing:
- `process_request(request)` - Called before sending
- `process_response(response)` - Called after receiving
- `process_stream(stream)` - Called during streaming

**Example:**
```python
class StreamMetricsMiddleware:
    def __init__(self):
        self.request_count = 0
        self.bytes_sent = 0
        self.bytes_received = 0

    async def process_stream(self, stream):
        self.request_count += 1
        # Process stream
        return stream

class StreamLoggingMiddleware:
    async def process_request(self, request):
        print(f"[STREAM REQUEST] {request}")
        return request

    async def process_response(self, response):
        print(f"[STREAM RESPONSE] {response}")
        return response

oxy.StreamableMCPClient(
    name="middleware_streaming",
    server_url="http://localhost:8000/mcp",
    middlewares=[
        StreamMetricsMiddleware(),
        StreamLoggingMiddleware()
    ]
)
```

**Compatibility:**
- Depends on MCP client library version
- If `session.add_middleware()` not available, warning logged
- Middleware ignored in incompatible versions

### timeout

- **Type**: `float`
- **默认**: `60`
- **Description**: Maximum execution time for each streaming tool call in seconds. Includes connection, streaming, 和 response time.

**Guidelines:**
- Quick streams: 10-30 seconds
- St和ard operations: 30-60 seconds
- Long-running streams: 60-300 seconds
- Very long processes: 300+ seconds

**Example:**
```python
oxy.StreamableMCPClient(
    name="long_streaming",
    server_url="http://api.example.com/mcp",
    timeout=300  # 5 minutes for long streams
)
```

## 方法

### init()

初始化到 MCP 服务器的 HTTP 流式连接。

```python
async def init(self, is_fetch_tools: bool = True) -> None
```

**参数:**
- `is_fetch_tools` (bool): 初始化后是否自动发现和注册工具。默认: `True`

**行为：**

取决于 `is_dynamic_headers` 和 `is_keep_alive`：

**情况 1：持久连接（`is_keep_alive=True` 且 `not is_dynamic_headers`）**
1. 使用 `build_url(server_url)` 构建服务器 URL
2. 建立流式 HTTP 客户端连接
3. 解包传输元组：`(read, write, cancel)`
4. 使用读/写流创建 MCP `ClientSession`
5. 将所有 `middlewares` 添加到会话
6. 初始化 MCP 协议
7. 如果 `is_fetch_tools=True`，发现工具
8. 存储 `_http_transport` 以供重用

**情况 2：临时连接（`is_keep_alive=False` 或 `is_dynamic_headers=True`）**
1. 创建临时流式 HTTP 连接
2. 通过 `list_tools()` 发现工具
3. 立即关闭连接
4. 后续调用创建新连接

**错误处理:**
- 失败时记录包含服务器名称的错误
- 自动调用 `cleanup()`
- 抛出包含"Server \{name\} error"的 `Exception`

**示例（内部使用）：**
```python
# Called automatically by MAS
async with MAS(oxy_space=[client, ...]) as mas:
    # client.init() called here
    ...
```

### call_tool()

在流式 MCP 服务器上执行工具。

```python
async def call_tool(
    self,
    tool_name: str,
    arguments: dict,
    headers: dict[str, str] = None
) -> Any
```

**参数:**
- `tool_name` (str): 要调用的工具名称
- `arguments` (dict): 工具特定的参数
- `headers` (dict, optional): 为此调用覆盖/合并的头

**返回：** 包含工具执行结果的 MCP 响应对象

**行为：**
1. 使用 `build_url(server_url)` 构建 URL
2. 使用头建立流式 HTTP 客户端
3. 解包传输：`(read, write, cancel)`
4. 创建临时 ClientSession
5. 初始化 MCP 协议
6. 使用参数调用工具
7. 返回响应
8. 自动关闭连接（异步上下文）

**注意：** 当 `is_keep_alive=False` 或 `is_dynamic_headers=True` 时使用。对于持久连接，`_execute()` 使用现有会话。

**示例（内部使用）：**
```python
# Called internally for transient connections
response = await client.call_tool(
    tool_name="stream_process",
    arguments={"data": "large_dataset"},
    headers={"X-Priority": "high"}
)
```

### list_tools()

从流式 MCP 服务器发现并注册工具。

```python
async def list_tools(self) -> None
```

**行为：**
1. 检查 `_session` 是否已初始化（持久模式）
2. 通过 MCP 协议调用 `_session.list_tools()`
3. 调用 `add_tools()` 创建 `MCPTool` 包装器
4. 在 MAS 中注册每个工具

**抛出：**
- 如果服务器未初始化（持久模式），抛出 `RuntimeError`

**注意：** 在临时模式下，在 `init()` 期间使用临时会话调用。

**示例（内部使用）：**
```python
# Called automatically during init()
await client.list_tools()
```

### add_tools()

为发现的工具创建 MCPTool 包装器。

```python
def add_tools(self, tools_response) -> None
```

**参数:**
- `tools_response`: 来自 `list_tools()` 的响应，包含工具定义

**行为：**
1. 提取排除敏感字段的模型转储:
   - `server_url`
   - `sse_url`
   - `headers`
   - `middlewares`
   - `included_tool_name_list`
   - `name`, `desc`, `mcp_client`, `server_name`, `input_schema`
2. 遍历响应中的工具
3. 为每个工具创建 `MCPTool` 实例，包含:
   - 工具名称和描述
   - 对此流式客户端的引用
   - 输入模式
   - 钩子函数（如果已配置）
4. 设置 MAS 引用并注册
5. 添加到 `included_tool_name_list`

**示例（内部使用）：**
```python
# Called by list_tools()
tools_response = await session.list_tools()
client.add_tools(tools_response)
```

### cleanup()

清理 HTTP 流式资源和连接。

```python
async def cleanup(self) -> None
```

**行为：**
1. 获取清理锁（防止并发清理）
2. 关闭 `AsyncExitStack`（终止 HTTP 连接和会话）
3. 优雅地处理 `asyncio.CancelledError`
4. 抑制其他异常
5. 将 `_session` 和 `_stdio_context` 设置为 `None`

**何时调用：**
- MAS 退出时自动调用
- 初始化错误时自动调用
- 如果需要可以手动调用

**示例（通常自动）：**
```python
# Automatic cleanup
async with MAS(oxy_space=[client, ...]) as mas:
    ...
# cleanup() called here
```

## 使用示例

### 基础流式传输

```python
from oxygent import MAS, oxy
import os

client = oxy.StreamableMCPClient(
    name="basic_streaming",
    server_url="http://localhost:8000/mcp"
)

oxy_space = [
    oxy.HttpLLM(name="llm", ...),
    client,
    oxy.ReActAgent(
        name="agent",
        llm_model="llm",
        tools=["basic_streaming"]
    )
]
```

### 使用身份验证

```python
secure_client = oxy.StreamableMCPClient(
    name="secure_streaming",
    server_url="https://api.example.com/mcp",
    headers={
        "Authorization": f"Bearer {os.getenv('STREAMING_TOKEN')}",
        "X-API-Version": "v2"
    }
)
```

### 使用动态头

```python
dynamic_client = oxy.StreamableMCPClient(
    name="dynamic_streaming",
    server_url="https://api.example.com/mcp",
    headers={"X-Base-Key": "default"},
    is_dynamic_headers=True,
    is_inherit_headers=True,
    is_keep_alive=False
)
```

### 使用中间件

```python
class RateLimitMiddleware:
    def __init__(self, max_requests=100):
        self.max_requests = max_requests
        self.request_count = 0

    async def process_request(self, request):
        if self.request_count >= self.max_requests:
            raise Exception("Rate limit exceeded")
        self.request_count += 1
        return request

middleware_client = oxy.StreamableMCPClient(
    name="rate_limited_streaming",
    server_url="http://localhost:8000/mcp",
    middlewares=[RateLimitMiddleware(max_requests=1000)]
)
```

### 高性能配置

```python
perf_client = oxy.StreamableMCPClient(
    name="high_perf_streaming",
    server_url="http://localhost:8000/mcp",
    is_keep_alive=True,          # Persistent connection
    timeout=120,                 # 2 minute timeout
    semaphore=64,                # 64 concurrent streams
    retries=1,                   # Fast fail
    is_permission_required=False # No permission overhead
)
```

### 多个流式服务器

```python
oxy_space = [
    oxy.HttpLLM(name="llm", ...),

    # Production streaming
    oxy.StreamableMCPClient(
        name="prod_stream",
        server_url="https://prod.example.com/mcp",
        headers={"Authorization": f"Bearer {os.getenv('PROD_TOKEN')}"}
    ),

    # Analytics streaming
    oxy.StreamableMCPClient(
        name="analytics_stream",
        server_url="https://analytics.example.com/mcp",
        headers={"Authorization": f"Bearer {os.getenv('ANALYTICS_TOKEN')}"}
    ),

    # Local dev streaming
    oxy.StreamableMCPClient(
        name="dev_stream",
        server_url="http://localhost:8000/mcp"
    ),

    oxy.ReActAgent(
        name="multi_stream_agent",
        llm_model="llm",
        tools=["prod_stream", "analytics_stream", "dev_stream"]
    )
]
```

## 错误处理

### 连接错误

```python
try:
    client = oxy.StreamableMCPClient(
        name="unavailable",
        server_url="http://localhost:9999/mcp"  # Not running
    )
    async with MAS(oxy_space=[client, ...]) as mas:
        await mas.call(...)
except Exception as e:
    print(f"Connection error: {e}")
```

### 超时错误

```python
client = oxy.StreamableMCPClient(
    name="strict_timeout",
    server_url="http://slow-server.com/mcp",
    timeout=10  # Very short timeout
)
# Streams exceeding 10 seconds will raise timeout
```

## 性能考虑

### 连接模式

|Aspect|Persistent|Transient|
|--------|-----------|-----------|
| **延迟** | 很低 | 高 |
| **吞吐量** | 很高 | 较低 |
| **资源使用** | 较高 | 较低 |
| **Dynamic Headers** | No | Yes |
| **Recommended For** | Production | Dev/Testing |

### Concurrency Optimization

```python
# High throughput
oxy.StreamableMCPClient(
    name="throughput",
    server_url="http://localhost:8000/mcp",
    semaphore=128,  # Many concurrent streams
    timeout=60
)

# Low latency
oxy.StreamableMCPClient(
    name="latency",
    server_url="http://localhost:8000/mcp",
    semaphore=16,
    timeout=5,
    retries=0  # No retries for fastest response
)
```

## 相关文档

- **[StreamableMCPClient Guide](/docs/tools-mcp-streamable)** - Main documentation 和 usage patterns
- **[StdioMCPClient API](/oxyapi/tools-mcp-stdio-api)** - Local process client API
- **[SSEMCPClient API](/oxyapi/tools-mcp-sse-api)** - HTTP SSE client API
- **[BaseMCPClient](/docs/tools-mcp-base)** - Base class documentation
- **[MCP Protocol](https://modelcontextprotocol.io/)** - Official MCP specification
