---
title: SSEOxyAgent API Reference
description: Complete API reference for the SSEOxyAgent class including constructor parameters, SSE communication methods, and remote agent integration
icon: Radio
---

## Class Overview

```python
from oxygent.oxy import SSEOxyGent

class SSEOxyGent(RemoteAgent):
    """Agent for communicating with remote services through Server-Sent Events (SSE) protocol.

    This agent serves as a basic proxy designed to provide functionality for communicating
    with remote services. Different agents interact with remote services through the SSE
    protocol, receiving OxyRequest objects and returning OxyResponse objects after
    completing communication tasks.
    """
```

SSEOxyGent inherits from `RemoteAgent` and is specifically designed for handling SSE communication with remote services. It supports real-time data streaming, event processing, and advanced features like call stack sharing.

## Constructor

### SSEOxyGent()

```python
SSEOxyGent(
    name: str,
    desc: str,
    server_url: str,
    is_share_call_stack: bool = True,
    **kwargs
)
```

#### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `name` | `str` | Required | Agent name for identification and calling |
| `desc` | `str` | Required | Agent description explaining its functionality |
| `server_url` | `str` | Required | Remote agent server URL (must start with http:// or https://) |
| `is_share_call_stack` | `bool` | `True` | Whether to share call stack information with remote agent |

#### Inherited Parameters (from RemoteAgent)

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `org` | `dict` | `{}` | Organization structure retrieved from remote system |

#### Inherited Parameters (from BaseAgent)

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `category` | `str` | `"agent"` | Tool/agent category |
| `input_schema` | `dict[str, Any]` | Config default | Input parameter schema |

#### Inherited Parameters (from BaseFlow)

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `is_master` | `bool` | `False` | Whether this is a master agent |
| `timeout` | `int` | `300` | Execution timeout in seconds |
| `func_process_input` | `Optional[Callable]` | `None` | Input processing function |
| `func_process_output` | `Optional[Callable]` | `None` | Output processing function |

## Core Attributes

### is_share_call_stack

```python
is_share_call_stack: bool = Field(
    True,
    description="Whether to share the call stack with the agent."
)
```

Boolean attribute controlling whether to share call stack information with remote services.

#### Mechanism

- **`True` (default)**: Share call stack information
  - Retains call stack and traversed node IDs
  - Remote service can understand complete call path
  - Helpful for debugging and request flow tracing

- **`False`**: Don't share call stack information
  - Removes call stack and node ID information
  - Sets caller to "user"
  - Protects privacy and security, simplifies data transmission

#### Use Cases

| Setting | Suitable Scenarios | Advantages | Disadvantages |
|---------|-------------------|------------|---------------|
| `True` | Debugging, tracing, complex workflows | Complete context, easy debugging | Large data transmission, potential info leakage |
| `False` | Privacy protection, simple queries | Streamlined data, privacy protection | Missing context, difficult debugging |

## Methods

### init()

```python
async def init(self) -> None
```

Async initialization method that establishes connection with remote service and retrieves organization structure.

#### Execution Flow

1. **Call parent initialization**: Execute RemoteAgent initialization
2. **Establish HTTP connection**: Use httpx.AsyncClient to connect to remote service
3. **Get organization info**: Retrieve organization structure from `/get_organization` endpoint
4. **Store organization data**: Store organization info in `self.org`

#### Exception Handling

- Network connection failure
- Remote service unavailable
- Organization info format error

### _execute()

```python
async def _execute(self, oxy_request: OxyRequest) -> OxyResponse
```

Core method for executing SSE communication.

#### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `oxy_request` | `OxyRequest` | Request object containing query and context information |

#### Returns

| Type | Description |
|------|-------------|
| `OxyResponse` | Result object containing remote agent response |

#### Execution Flow

1. **Build request payload**
   - Serialize OxyRequest object
   - Update caller category to "user"
   - Handle call stack info based on `is_share_call_stack`

2. **Establish SSE connection**
   - Set SSE-specific HTTP headers
   - Send POST request to `/sse/chat` endpoint
   - Establish persistent connection

3. **Process SSE data stream**
   - Read SSE data line by line
   - Parse messages with `data:` prefix
   - Handle different event types

4. **Event type processing**
   - `"answer"`: Extract final answer
   - `"tool_call"`: Handle tool call events
   - `"observation"`: Handle observation results
   - `"done"`: Terminate connection
   - Other types: Forward directly

5. **Return result**
   - Construct OxyResponse object
   - Set status to COMPLETED
   - Return final answer

#### SSE Data Format

```
data: {"type": "answer", "content": "This is the answer"}
data: {"type": "tool_call", "content": {...}}
data: {"type": "observation", "content": {...}}
data: done
```

### get_org()

```python
def get_org(self) -> list
```

Get organization structure copy marked as remote.

#### Returns

| Type | Description |
|------|-------------|
| `list` | Organization structure list marked with `is_remote=True` |

#### Functionality

- Creates deep copy of organization structure
- Adds `is_remote=True` marker to all nodes
- Recursively processes nested child nodes

### Inherited Methods

#### From RemoteAgent

- `check_protocol()` - Validate server URL protocol

#### From BaseAgent

- `_pre_process()` - Pre-process request
- `_pre_save_data()` - Save trace data

#### From BaseFlow

- `call()` - Execute agent
- `set_mas()` - Set MAS reference

## Usage Examples

### Basic SSE Agent

```python
from oxygent import MAS, oxy
from oxygent.utils.env_utils import get_env_var

oxy_space = [
    oxy.HttpLLM(
        name="default_llm",
        api_key=get_env_var("DEFAULT_LLM_API_KEY"),
        base_url=get_env_var("DEFAULT_LLM_BASE_URL"),
        model_name=get_env_var("DEFAULT_LLM_MODEL_NAME"),
    ),
    oxy.SSEOxyGent(
        name="remote_agent",
        desc="Remote SSE agent",
        server_url="http://localhost:8082",
        is_share_call_stack=True,
    )
]

async def main():
    async with MAS(oxy_space=oxy_space) as mas:
        result = await mas.call(
            callee="remote_agent",
            arguments={"query": "Hello from SSE client"}
        )
        print(result.output)
```

### Without Call Stack Sharing

```python
oxy.SSEOxyGent(
    name="private_agent",
    desc="Privacy-protected remote agent",
    server_url="https://secure-service.example.com",
    is_share_call_stack=False,  # Don't share call stack
)
```

### Usage in Workflow

```python
from oxygent import OxyRequest

async def workflow(oxy_request: OxyRequest):
    """Workflow function integrating SSE agent"""

    # Get current time
    time_response = await oxy_request.call(
        callee="time_agent",  # SSE time agent
        arguments={"query": "What time is it now?"}
    )

    # Handle math calculation
    if "calculate" in oxy_request.get_query():
        calc_response = await oxy_request.call(
            callee="calc_agent",  # SSE calculation agent
            arguments={"query": oxy_request.get_query()}
        )
        return f"Time: {time_response.output}, Calculation result: {calc_response.output}"

    return f"Current time: {time_response.output}"

oxy_space = [
    oxy.HttpLLM(name="default_llm", ...),

    # Remote time service
    oxy.SSEOxyGent(
        name="time_agent",
        desc="Time query agent",
        server_url="http://time-service:8082",
    ),

    # Remote calculation service
    oxy.SSEOxyGent(
        name="calc_agent",
        desc="Calculation agent",
        server_url="http://calc-service:8083",
    ),

    # Workflow agent
    oxy.WorkflowAgent(
        name="main_agent",
        desc="Main workflow agent",
        func_workflow=workflow,
        llm_model="default_llm",
        is_master=True,
    ),
]
```

### Multi-Service Integration

```python
# Create multiple SSE agents connecting to different services
services = [
    {"name": "nlp_service", "url": "http://nlp:8080", "desc": "Natural language processing service"},
    {"name": "vision_service", "url": "http://vision:8081", "desc": "Computer vision service"},
    {"name": "search_service", "url": "http://search:8082", "desc": "Search service"},
]

oxy_space = [oxy.HttpLLM(name="default_llm", ...)]

for service in services:
    oxy_space.append(
        oxy.SSEOxyGent(
            name=service["name"],
            desc=service["desc"],
            server_url=service["url"],
            is_share_call_stack=True,
        )
    )

# Parallel call to multiple services
oxy_space.append(
    oxy.ParallelAgent(
        name="multi_service_agent",
        desc="Multi-service parallel processing",
        llm_model="default_llm",
        permitted_tool_name_list=["nlp_service", "vision_service", "search_service"],
        is_master=True,
    )
)
```

## SSE Protocol Details

### SSE Basics

Server-Sent Events (SSE) is part of the HTML5 specification, providing server-to-client unidirectional real-time data update technology.

#### Features

- **Unidirectional communication**: Server pushes data to client
- **Persistent connection**: Maintains long connection for real-time updates
- **Auto-reconnection**: Automatically reconnects when connection drops
- **Event-driven**: Event-based data transmission

#### HTTP Headers

```python
headers = {
    "Accept": "text/event-stream",
    "Content-Type": "application/json",
}
```

### Data Format

SSE data is transmitted in specific format:

```
data: {"type": "answer", "content": "Response content"}

data: {"type": "tool_call", "content": {"caller": "agent1", "callee": "tool1"}}

data: {"type": "observation", "content": {"result": "Execution result"}}

data: done
```

### Event Types

| Event Type | Description | Processing Method |
|------------|-------------|-------------------|
| `answer` | Final answer | Extract content as response |
| `tool_call` | Tool call | Forward to local MAS |
| `observation` | Observation result | Forward to local MAS |
| `done` | Connection end | Terminate SSE connection |
| Others | Custom events | Forward directly |

## Configuration Options

### Connection Configuration

- `server_url`: Remote server URL
- `timeout`: Connection timeout
- HTTP header configuration

### Call Stack Configuration

- `is_share_call_stack`: Whether to share call stack
- Call stack processing strategy
- Privacy protection settings

### Error Handling Configuration

- Reconnection strategy
- Timeout handling
- Exception recovery

## Performance Considerations

### Connection Management

1. **Connection reuse**: Reasonably manage SSE connections
2. **Timeout settings**: Set appropriate timeout values
3. **Resource cleanup**: Timely release connection resources

### Data Transmission

1. **Data compression**: Reduce transmission data volume
2. **Batch processing**: Batch process multiple events
3. **Caching strategy**: Cache common responses

### Error Recovery

1. **Auto-reconnection**: Implement auto-reconnection mechanism
2. **Fallback strategy**: Fallback handling when connection fails
3. **Monitoring alerts**: Monitor connection status and performance

## Error Handling

### Common Errors

1. **Connection failure**
   ```python
   # Check server URL and network connection
   try:
       async with httpx.AsyncClient() as client:
           response = await client.get(f"{server_url}/health")
   except httpx.ConnectError:
       logger.error("Unable to connect to remote server")
   ```

2. **SSE data format error**
   ```python
   try:
       data = json.loads(sse_data)
   except json.JSONDecodeError:
       logger.error(f"Invalid SSE data format: {sse_data}")
   ```

3. **Timeout handling**
   ```python
   async with asyncio.timeout(30):  # 30 second timeout
       async with session.post(url, data=payload) as resp:
           # Process SSE stream
   ```

### Error Recovery

1. **Reconnection mechanism**
   ```python
   max_retries = 3
   for attempt in range(max_retries):
       try:
           return await self._execute(oxy_request)
       except Exception as e:
           if attempt == max_retries - 1:
               raise
           await asyncio.sleep(2 ** attempt)  # Exponential backoff
   ```

2. **Fallback handling**
   ```python
   try:
       return await sse_agent.call(arguments)
   except SSEConnectionError:
       # Fallback to local processing
       return await local_agent.call(arguments)
   ```

## Security Considerations

### Data Protection

1. **HTTPS connection**: Use HTTPS to protect data transmission
2. **Call stack privacy**: Carefully share call stack information
3. **Input validation**: Validate remote service responses

### Access Control

1. **Authentication**: Implement appropriate authentication mechanisms
2. **Authorization**: Control access to remote services
3. **Audit logs**: Record all remote calls

## Best Practices

### Design Principles

1. **Service separation**: Separate different functionalities into different remote services
2. **Stateless design**: Remote services should be stateless
3. **Idempotency**: Ensure operation idempotency
4. **Fault tolerance**: Design fault tolerance and recovery mechanisms

### Deployment Recommendations

1. **Load balancing**: Use load balancing to distribute requests
2. **Health checks**: Implement service health checks
3. **Monitoring alerts**: Monitor service status and performance
4. **Version management**: Manage service versions and compatibility

### Debugging Tips

1. **Logging**: Detailed logging of SSE communication
2. **Event tracing**: Trace complete event flow
3. **Performance analysis**: Analyze communication performance and bottlenecks
4. **Testing tools**: Use specialized SSE testing tools

## Related Links

- [SSEOxyAgent Main Documentation](/docs/agents-sse-agent) - Overview and usage guide
- [WorkflowAgent API](/oxyapi/agents-workflow-api) - Workflow agent integration
- [ParallelAgent API](/oxyapi/agents-parallel-api) - Parallel agent API
- [Context Documentation](/docs/context) - Context management system
