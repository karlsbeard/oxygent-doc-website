---
title: PlanAndSolve API 参考
description: PlanAndSolve 流程的完整 API 参考文档，包括构造函数参数和执行方法
icon: Code
---

## 类概述

```python
from oxygent.oxy.flows import PlanAndSolve

plan_solve_flow = PlanAndSolve(
    name="task_executor",
    desc="Decomposes complex tasks and executes them step-by-step",
    planner_agent_name="planner_agent",
    executor_agent_name="executor_agent",
    enable_replanner=False,
    max_replan_rounds=30,
    llm_model="default_llm"
)
```

## 构造函数参数

### 核心参数

| 参数 | 类型 | 默认值 | 描述 |
|-----------|------|---------|-------------|
| `name` | str | 必需 | 流程的唯一标识符 |
| `planner_agent_name` | str | "planner_agent" | 规划器代理的名称 |
| `executor_agent_name` | str | "executor_agent" | 执行器代理的名称 |

### 规划参数

| 参数 | 类型 | 默认值 | 描述 |
|-----------|------|---------|-------------|
| `max_replan_rounds` | int | 30 | 最大规划迭代次数 |
| `pre_plan_steps` | List[str] | None | 预定义的计划步骤（绕过规划器） |
| `enable_replanner` | bool | False | 启用动态重新规划 |

### LLM 和解析参数

| 参数 | 类型 | 默认值 | 描述 |
|-----------|------|---------|-------------|
| `llm_model` | str | "default_llm" | 用于后备操作的 LLM 模型名称 |
| `func_parse_planner_response` | Callable | None | 自定义规划器响应解析器 |
| `pydantic_parser_planner` | PydanticOutputParser | Plan parser | 规划器输出解析器 |
| `func_parse_replanner_response` | Callable | None | 自定义重新规划器响应解析器 |
| `pydantic_parser_replanner` | PydanticOutputParser | Action parser | 重新规划器输出解析器 |

### 可选参数

| 参数 | 类型 | 默认值 | 描述 |
|-----------|------|---------|-------------|
| `desc` | str | "" | 流程用途的描述 |
| `timeout` | int | 100 | 最大执行时间（秒） |
| `is_permission_required` | bool | False | 是否需要权限 |
| `category` | str | "flow" | 类别分类 |
| `is_master` | bool | False | 是否为主入口点 |

## 参数详情

### `name`
- **类型**：`str`
- **必需**：是
- **描述**：PlanAndSolve 流程在多智能体系统中的唯一标识符。

**示例：**
```python
PlanAndSolve(
    name="complex_task_solver",
    planner_agent_name="planner",
    executor_agent_name="executor"
)
```

### `planner_agent_name`
- **类型**：`str`
- **默认值**：`"planner_agent"`
- **描述**：负责将复杂任务分解为有序子目标的代理名称。

**要求：**
- 代理必须在同一多智能体系统中注册
- 应该能够产生结构化输出（Plan 模型）
- 通常使用具有良好规划能力的 LLM

**示例：**
```python
PlanAndSolve(
    name="solver",
    planner_agent_name="gpt4_planner",  # 自定义规划器代理
    executor_agent_name="executor"
)
```

### `executor_agent_name`
- **类型**：`str`
- **默认值**：`"executor_agent"`
- **描述**：负责执行单个子目标的代理名称。

**要求：**
- 代理必须在同一多智能体系统中注册
- 应该能够访问必要的工具
- 通常是具有工具访问权限的 ReActAgent

**示例：**
```python
PlanAndSolve(
    name="solver",
    planner_agent_name="planner",
    executor_agent_name="react_executor"  # 具有工具的 ReActAgent
)
```

### `max_replan_rounds`
- **类型**：`int`
- **默认值**：`30`
- **描述**：防止无限循环的最大规划迭代次数。

**使用指南：**
- 简单任务：5-10 轮
- 中等复杂度：10-20 轮
- 复杂任务：20-30 轮
- 非常复杂：30-50 轮（谨慎增加）

**示例：**
```python
PlanAndSolve(
    name="complex_solver",
    max_replan_rounds=50,  # 为非常复杂的任务允许更多迭代
    ...
)
```

### `pre_plan_steps`
- **类型**：`List[str]` | `None`
- **默认值**：`None`
- **描述**：绕过初始规划阶段的预定义计划步骤。

**何时使用：**
- 已知的固定工作流程
- 严格控制执行顺序
- 测试特定执行路径
- 模板化程序

**示例：**
```python
PlanAndSolve(
    name="predefined_solver",
    pre_plan_steps=[
        "Validate input data",
        "Query database for user information",
        "Process results and format output",
        "Return formatted response"
    ],
    executor_agent_name="executor"
)
```

**注意：** 当提供 `pre_plan_steps` 时，规划器代理不会被初始调用。

### `enable_replanner`
- **类型**：`bool`
- **默认值**：`False`
- **描述**：基于执行结果启用动态重新规划。

**启用时：**
- 每步之后，重新规划器评估进度
- 可以根据结果修改剩余计划
- 如果目标达成可以提前终止
- 需要设置 `replanner_agent_name`

**用法：**
```python
# 基础模式（无重新规划）
PlanAndSolve(
    name="basic_solver",
    enable_replanner=False,  # 线性执行计划
    ...
)

# 高级模式（带重新规划）
PlanAndSolve(
    name="adaptive_solver",
    enable_replanner=True,  # 动态调整计划
    replanner_agent_name="replanner_agent",
    ...
)
```

**考虑事项：**
- 更灵活但更慢
- 可以处理意外情况
- 存在循环规划的风险（使用 `max_replan_rounds`）

### `llm_model`
- **类型**：`str`
- **默认值**：`"default_llm"`
- **描述**：当超过最大轮数时用于后备操作的 LLM 模型名称。

**示例：**
```python
PlanAndSolve(
    name="solver",
    llm_model="gpt-4",  # 用于后备合成
    ...
)
```

### `func_parse_planner_response`
- **类型**：`Optional[Callable[[str], LLMResponse]]`
- **默认值**：`None`
- **描述**：解析规划器代理响应的自定义函数。

**何时使用：**
- 自定义规划器输出格式
- 非标准 Plan 结构
- 遗留系统集成

**函数签名：**
```python
def custom_planner_parser(response: str) -> Plan:
    """
    Args:
        response: 规划器代理的原始字符串输出

    Returns:
        Plan: 包含步骤列表的解析计划
    """
    # 自定义解析逻辑
    steps = extract_steps_from_response(response)
    return Plan(steps=steps)
```

**示例：**
```python
PlanAndSolve(
    name="custom_solver",
    func_parse_planner_response=custom_planner_parser,
    pydantic_parser_planner=None,  # 禁用默认解析器
    ...
)
```

### `pydantic_parser_planner`
- **类型**：`PydanticOutputParser`
- **默认值**：`PydanticOutputParser(output_cls=Plan)`
- **描述**：用于结构化规划器输出的 Pydantic 解析器。

**默认 Plan 模型：**
```python
class Plan(BaseModel):
    steps: List[str] = Field(
        description="different steps to follow, should be in sorted order"
    )
```

**自定义示例：**
```python
from pydantic import BaseModel, Field
from oxygent.utils.llm_pydantic_parser import PydanticOutputParser

class CustomPlan(BaseModel):
    steps: List[str]
    priority: str
    estimated_time: int

custom_parser = PydanticOutputParser(output_cls=CustomPlan)

PlanAndSolve(
    name="solver",
    pydantic_parser_planner=custom_parser,
    ...
)
```

### `func_parse_replanner_response`
- **类型**：`Optional[Callable[[str], LLMResponse]]`
- **默认值**：`None`
- **描述**：解析重新规划器代理响应的自定义函数。

**函数签名：**
```python
def custom_replanner_parser(response: str) -> Action:
    """
    Args:
        response: 重新规划器代理的原始字符串输出

    Returns:
        Action: Response（完成）或 Plan（继续）
    """
    # 自定义解析逻辑
    if is_complete(response):
        return Action(action=Response(response=final_answer))
    else:
        return Action(action=Plan(steps=new_steps))
```

### `pydantic_parser_replanner`
- **类型**：`PydanticOutputParser`
- **默认值**：`PydanticOutputParser(output_cls=Action)`
- **描述**：用于结构化重新规划器输出的 Pydantic 解析器。

**默认 Action 模型：**
```python
class Response(BaseModel):
    response: str

class Plan(BaseModel):
    steps: List[str]

class Action(BaseModel):
    action: Union[Response, Plan] = Field(
        description="Action to perform. Use Response to answer user, Plan to continue."
    )
```

## 方法

### `_execute(oxy_request: OxyRequest) -> OxyResponse`

**内部方法** - 编排计划和解决工作流程。

**执行流程：**
1. **初始规划**（如果 `pre_plan_steps` 为 None）：
   - 使用格式化查询调用规划器代理
   - 将响应解析为 Plan 模型
   - 提取步骤列表

2. **步骤执行循环**：
   - 对于计划中的每个步骤：
     - 使用上下文（过去步骤）格式化步骤
     - 调用执行器代理
     - 记录执行结果
     - 更新 past_steps 历史记录

3. **重新规划**（如果 `enable_replanner=True`）：
   - 每步之后，调用重新规划器代理
   - 评估：继续（新 Plan）或终止（Response）
   - 如果继续则更新计划

4. **终止**：
   - 计划耗尽：返回最终执行器输出
   - 重新规划器终止：返回 Response
   - 超过最大轮数：使用 LLM 后备

**注意：** 内部方法 - 请使用 `mas.call()` 或 `oxy_request.call()`。

## 执行流程图

```
用户请求
    ↓
初始规划（除非提供了 pre_plan_steps）
    ↓
planner_agent → Plan(steps=[...])
    ↓
┌─── 执行循环（max_replan_rounds）───┐
│                                           │
│  当前步骤 = plan_steps[0]            │
│    ↓                                      │
│  使用 past_steps 上下文格式化          │
│    ↓                                      │
│  executor_agent 执行步骤            │
│    ↓                                      │
│  在 past_steps 中记录结果             │
│    ↓                                      │
│  [如果 enable_replanner]                   │
│    ↓                                      │
│  replanner_agent 评估进度      │
│    ↓                                      │
│  Response? → 返回最终答案         │
│  Plan? → 更新 plan_steps               │
│    ↓                                      │
│  [如果 !enable_replanner]                  │
│    ↓                                      │
│  从计划中移除已完成步骤         │
│    ↓                                      │
│  plan_steps 为空? → 返回结果       │
│    ↓                                      │
└───────────────────────────────────────────┘
    ↓
OxyResponse(state=COMPLETED, output=result)
```

## 返回值

### OxyResponse 结构

```python
{
    "state": OxyState.COMPLETED,
    "output": "final execution result"  # 来自执行器或重新规划器
}
```

## 使用示例

### 基础计划和解决

```python
from oxygent import MAS, oxy

oxy_space = [
    oxy.HttpLLM(name="default_llm", ...),
    oxy.ChatAgent(
        name="planner_agent",
        prompt="You are a task planner. Break down complex tasks into ordered steps."
    ),
    oxy.ReActAgent(
        name="executor_agent",
        tools=["time_tool", "calculator", "search"],
        llm_model="default_llm"
    ),
    oxy.flows.PlanAndSolve(
        name="task_solver",
        planner_agent_name="planner_agent",
        executor_agent_name="executor_agent",
        max_replan_rounds=20
    )
]

async def main():
    async with MAS(oxy_space=oxy_space) as mas:
        result = await mas.call(
            callee="task_solver",
            arguments={"query": "Find the current time and calculate 15% tax on $1000"}
        )
        print(result.output)
```

### 使用预定义步骤

```python
oxy.flows.PlanAndSolve(
    name="fixed_workflow",
    pre_plan_steps=[
        "Validate user input format",
        "Query database for existing records",
        "Process and transform data",
        "Save results to database",
        "Generate confirmation message"
    ],
    executor_agent_name="workflow_executor",
    max_replan_rounds=10
)
```

### 使用动态重新规划

```python
oxy_space = [
    oxy.HttpLLM(name="default_llm", ...),
    oxy.ChatAgent(name="planner_agent", ...),
    oxy.ChatAgent(name="replanner_agent", ...),  # 额外的代理
    oxy.ReActAgent(name="executor_agent", ...),
    oxy.flows.PlanAndSolve(
        name="adaptive_solver",
        planner_agent_name="planner_agent",
        executor_agent_name="executor_agent",
        enable_replanner=True,
        replanner_agent_name="replanner_agent",  # enable_replanner=True 时必需
        max_replan_rounds=30
    )
]
```

### 自定义解析函数

```python
def parse_custom_plan(response: str) -> Plan:
    """以自定义格式解析规划器输出。"""
    lines = response.split("\n")
    steps = [line.strip("- ").strip() for line in lines if line.strip().startswith("-")]
    return Plan(steps=steps)

oxy.flows.PlanAndSolve(
    name="custom_solver",
    func_parse_planner_response=parse_custom_plan,
    pydantic_parser_planner=None,  # 禁用默认
    ...
)
```

## 最佳实践

### 1. 选择合适的规划器代理

使用有能力的 LLM 进行规划：

```python
# ✅ 好：使用高级 LLM 进行规划
oxy.ChatAgent(
    name="planner",
    llm_model="gpt-4",  # 强大的规划能力
    prompt="Break down tasks into clear, ordered steps"
)

# ⚠️ 注意：较弱的模型可能产生糟糕的计划
oxy.ChatAgent(
    name="planner",
    llm_model="gpt-3.5-turbo",  # 可能在复杂规划中遇到困难
    ...
)
```

### 2. 设置合适的最大轮数

平衡完整性和性能：

```python
# 简单、定义明确的任务
PlanAndSolve(name="simple", max_replan_rounds=10, ...)

# 复杂、多方面的任务
PlanAndSolve(name="complex", max_replan_rounds=30, ...)
```

### 3. 对固定工作流程使用预定义步骤

```python
# 当工作流程已知且固定时
PlanAndSolve(
    name="onboarding_flow",
    pre_plan_steps=[
        "Create user account",
        "Send welcome email",
        "Assign default permissions",
        "Log onboarding event"
    ],
    ...
)
```

### 4. 为动态场景启用重新规划器

```python
# 对于可能需要适应的不可预测任务
PlanAndSolve(
    name="research_task",
    enable_replanner=True,  # 根据发现进行适应
    ...
)
```

### 5. 提供清晰的执行器指令

```python
oxy.ReActAgent(
    name="executor",
    additional_prompt="Execute ONLY the current step. Do not skip or repeat steps.",
    ...
)
```

## 常见模式

### 模式：数据管道

```python
PlanAndSolve(
    name="data_pipeline",
    pre_plan_steps=[
        "Extract data from source",
        "Validate data quality",
        "Transform data format",
        "Load data to destination"
    ],
    executor_agent_name="pipeline_executor"
)
```

### 模式：研究任务

```python
PlanAndSolve(
    name="research_flow",
    planner_agent_name="research_planner",
    executor_agent_name="research_executor",
    enable_replanner=True,  # 根据发现进行适应
    max_replan_rounds=40
)
```

### 模式：多步骤分析

```python
PlanAndSolve(
    name="analysis_flow",
    pre_plan_steps=[
        "Load and prepare data",
        "Perform statistical analysis",
        "Generate visualizations",
        "Compile report"
    ],
    executor_agent_name="analyst_agent"
)
```

## 与其他流程的比较

| 功能 | PlanAndSolve | Workflow | ParallelFlow |
|---------|--------------|----------|--------------|
| **规划** | 自动 | 手动 | 不适用 |
| **执行** | 顺序 | 自定义 | 并行 |
| **重新规划** | 可选 | 手动 | 不适用 |
| **复杂度** | 高 | 可变 | 低 |
| **用例** | 多步骤任务 | 自定义逻辑 | 独立操作 |

## 相关 API 参考

- [Workflow API](/oxyapi/flows-workflow-api) - 自定义工作流程流 API
- [ParallelFlow API](/oxyapi/flows-parallel-api) - 并行执行流 API
- [Reflexion API](/oxyapi/flows-reflexion-api) - 自我评估流 API
- [ReActAgent API](/oxyapi/agents-react-api) - 执行器代理 API
- [ChatAgent API](/oxyapi/agents-chat-api) - 规划器代理 API
