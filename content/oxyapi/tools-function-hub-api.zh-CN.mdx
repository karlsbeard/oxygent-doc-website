---
title: FunctionHub API 参考
description: FunctionHub 类的完整 API 参考文档
icon: Code
---

## 类定义

```python
from oxygent import oxy

# Create a FunctionHub instance
tools = oxy.FunctionHub(
    name="my_tools",
    desc="Collection of custom tools",
    timeout=60,
    is_permission_required=True
)

# Register functions using decorator
@tools.tool(description="Tool description")
def my_function(param: str):
    return result
```

## 构造函数参数

### 必需参数

|参数|类型|必需|默认值|描述|
|-----------|------|----------|---------|-------------|
| `name` | `str` | **是** | - | FunctionHub 的唯一标识符。代理在其 `tools` 列表中引用此名称 |

### 核心配置

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `desc` | `str` | `""` | 此工具集合的可读描述 |
| `category` | `str` | `"tool"` | 类别分类（自动设置） |

### 执行控制

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `timeout` | `float` | `60` | 每个工具的最大执行时间（秒）（默认：1 分钟） |
| `semaphore` | `int` | `16` | 最大并发工具执行数 |
| `retries` | `int` | `2` | 失败时的重试次数 |
| `delay` | `float` | `1.0` | 重试尝试之间的延迟（秒） |

### 权限与安全

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `is_permission_required` | `bool` | `True` | 代理是否需要权限来调用此中心的工具 |
| `is_save_data` | `bool` | `True` | 是否将执行跟踪保存到 Elasticsearch |

### 内部属性（只读）

|属性|类型|描述|
|-----------|------|-------------|
| `func_dict` | `dict` | 将函数名称映射到（描述，async_func）元组的内部注册表 |

## 方法

### tool()

用于在中心注册函数为工具的装饰器。

```python
@function_hub.tool(description: str)
def my_function(...):
    ...
```

**参数：**
- `description` (str): **必需** - 工具功能的可读描述。在选择工具时会向 LLM 显示此内容。

**返回：**装饰器函数，注册并返回被装饰函数的异步版本

**行为：**
1. 检查函数是否已经是异步的
2. 如果是同步的，将其包装在异步函数中
3. 在 `func_dict` 中注册 `(描述, async_func)` 元组，以函数名称作为键
4. 返回函数的异步版本

**示例：**
```python
tools = oxy.FunctionHub(name="math_tools")

@tools.tool(description="Add two numbers")
def add(a: int, b: int):
    return a + b

# Internally stored as:
# tools.func_dict["add"] = ("Add two numbers", async_add_wrapper)
```

### init()

MAS 调用的内部初始化方法。用户不直接调用。

```python
async def init(self)
```

**行为：**
1. 调用 `super().init()` 进行基础初始化
2. 遍历 `func_dict`
3. 为每个函数创建 `FunctionTool` 实例
4. 在 MAS 中注册每个 `FunctionTool`

**内部发生的示例：**
```python
# init 之前：
hub.func_dict = {
    "add": ("Add two numbers", async_add_func),
    "multiply": ("Multiply two numbers", async_multiply_func)
}

# init 之后（MAS 内部）：
mas.oxy_name_to_oxy = {
    "math_tools": hub,           # 中心本身
    "add": FunctionTool(...),    # 单独的工具
    "multiply": FunctionTool(...) # 单独的工具
}
```

## 函数签名模式

### 参数类型注解

FunctionHub 从函数签名中提取模式：

```python
@tools.tool(description="Example function")
def example(
    # Basic types
    text: str,                      # Required string parameter
    number: int,                    # Required integer parameter
    decimal: float,                 # Required float parameter
    flag: bool,                     # Required boolean parameter

    # Optional with defaults
    optional_str: str = "default",  # Optional with default value
    optional_int: int = 42,         # Optional with default value

    # Pydantic Fields (recommended)
    detailed: str = Field(description="Detailed parameter description"),
    with_default: int = Field(default=10, description="Parameter with default"),

    # Complex types
    items: list = Field(description="List of items"),
    config: dict = Field(description="Configuration dictionary"),
    tags: list[str] = Field(default=[], description="List of strings"),

    # Context access (not shown to LLM)
    oxy_request: OxyRequest = None  # Automatically injected if present
):
    return result
```

### 模式提取规则

|Pattern|必需|类型|描述|
|---------|----------|------|-------------|
| `param: str` | 是 | `str` | 必需参数，无描述 |
| `param: str = "default"` | 否 | `str` | 可选，带默认值 |
| `param: str = Field(description="...")` | 是 | `str` | 必需，带描述 |
| `param: str = Field(default="...", description="...")` | 否 | `str` | 可选，带描述 |
| `param: list` | 是 | `array` | 必需列表 |
| `param: dict` | 是 | `对象` | 必需字典 |
| `oxy_request: OxyRequest` | 排除 | - | 上下文参数（不在模式中） |

### 返回值

函数可以返回任何 JSON 可序列化的类型：

```python
@tools.tool(description="Returns a string")
def string_result():
    return "Hello, World!"

@tools.tool(description="Returns a number")
def number_result():
    return 42

@tools.tool(description="Returns a list")
def list_result():
    return [1, 2, 3, 4, 5]

@tools.tool(description="Returns a dict")
def dict_result():
    return {"key": "value", "count": 10}

@tools.tool(description="Returns complex object")
def complex_result():
    return {
        "status": "success",
        "data": [1, 2, 3],
        "metadata": {"timestamp": "2024-01-01"}
    }
```

## 生成的 FunctionTool 属性

当 FunctionHub 在 `init()` 期间创建 FunctionTool 实例时，每个工具都有：

|Attribute|类型|Source|描述|
|-----------|------|--------|-------------|
| `name` | `str` | 函数名称 | 函数的 `__name__` 属性 |
| `desc` | `str` | 装饰器参数 | 传递给 `@tool()` 的描述 |
| `func_process` | `Callable` | 函数 | 要执行的异步函数 |
| `input_schema` | `dict` | 自动提取 | 包含 `properties` 和 `required` 字段的模式 |
| `desc_for_llm` | `str` | 自动生成 | 向 LLM 显示的格式化描述 |
| `timeout` | `float` | Hub 配置 | 从 FunctionHub 继承 |
| `is_permission_required` | `bool` | Hub 配置 | 从 FunctionHub 继承 |
| `needs_oxy_request` | `bool` | 自动检测 | 如果函数有 `OxyRequest` 参数则为 True |

**生成的模式示例：**
```python
@tools.tool(description="Add two numbers")
def add(
    a: int = Field(description="First number"),
    b: int = Field(description="Second number")
):
    return a + b

# Generated FunctionTool has:
{
    "name": "add",
    "desc": "Add two numbers",
    "input_schema": {
        "properties": {
            "a": {"type": "int", "description": "First number"},
            "b": {"type": "int", "description": "Second number"}
        },
        "required": ["a", "b"]
    }
}
```

## OxyRequest 集成

### 访问上下文

函数可以接收 `OxyRequest` 来访问执行上下文：

```python
from oxygent import OxyRequest

@tools.tool(description="Context-aware tool")
async def context_tool(
    oxy_request: OxyRequest,  # Automatically injected
    param: str = Field(description="Parameter")
):
    # Access query and memory
    query = oxy_request.get_query()
    history = oxy_request.get_short_memory()

    # Access data scopes
    arguments = oxy_request.get_arguments()
    shared = oxy_request.get_shared_data("key")
    group = oxy_request.get_group_data("key")
    global_data = oxy_request.get_global_data("key")

    # Call other components
    response = await oxy_request.call(
        callee="other_agent",
        arguments={"query": param}
    )

    # Send messages
    await oxy_request.send_message({
        "type": "status",
        "content": "Processing..."
    })

    return result
```

**关键点：**
- `OxyRequest` 参数**必须**精确命名为 `oxy_request`
- 它会**自动从**工具模式中排除
- LLM 看不到此参数，也不需要提供它
- 它由框架自动注入

### 签名检测

```python
# WITHOUT OxyRequest
@tools.tool(description="Simple tool")
def simple(param: str):
    return param.upper()

# Schema: {"properties": {"param": {...}}, "必需": ["param"]}
# needs_oxy_request: False

# WITH OxyRequest
@tools.tool(description="Context-aware tool")
async def aware(oxy_request: OxyRequest, param: str):
    query = oxy_request.get_query()
    return f"{query}: {param}"

# Schema: {"properties": {"param": {...}}, "必需": ["param"]}
# needs_oxy_request: True
# (OxyRequest excluded from schema)
```

## 异步 vs 同步函数

### 自动转换

FunctionHub 自动包装同步函数：

```python
# Synchronous function
@tools.tool(description="Sync function")
def sync_func(param: str):
    # Regular synchronous code
    result = expensive_computation(param)
    return result

# Internally converted to:
# async def sync_func_wrapper(*args, **kwargs):
# return sync_func(*args, **kwargs)
```

**注意：** 同步函数会阻塞事件循环。对于 I/O 操作使用 async。

### 异步函数

对于 I/O 密集型操作使用 async：

```python
import aiohttp

@tools.tool(description="Async function")
async def async_func(url: str):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

# Already async, no wrapping needed
```

### 最佳实践

|Operation Type|Use Sync|Use Async|
|----------------|----------|-----------|
| 纯计算 | ✓ | ✗ |
| 数学运算 | ✓ | ✗ |
| 字符串操作 | ✓ | ✗ |
| HTTP 请求 | ✗ | ✓ |
| 数据库查询 | ✗ | ✓ |
| 文件 I/O | ✗ | ✓ |
| 休眠/延迟 | ✗ | ✓ (使用 asyncio.sleep) |

## 使用示例

### 基础示例

```python
from oxygent import MAS, oxy
from pydantic import Field

# Create hub
math_tools = oxy.FunctionHub(name="math_tools")

# Register functions
@math_tools.tool(description="Add two numbers")
def add(a: int, b: int):
    return a + b

@math_tools.tool(description="Subtract two numbers")
def subtract(a: int, b: int):
    return a - b

# Use in MAS
oxy_space = [
    oxy.HttpLLM(name="gpt4", ...),
    math_tools,
    oxy.ReActAgent(
        name="calculator",
        tools=["math_tools"],  # Reference hub name
        llm_model="gpt4"
    )
]

async def main():
    async with MAS(oxy_space=oxy_space) as mas:
        await mas.start_web_service(first_query="What is 10 + 5?")
```

### 多个 Hub

```python
# Create multiple hubs for organization
math_tools = oxy.FunctionHub(name="math_tools")
text_tools = oxy.FunctionHub(name="text_tools")
api_tools = oxy.FunctionHub(name="api_tools")

# Register math functions
@math_tools.tool(description="Calculate factorial")
def factorial(n: int):
    return math.factorial(n)

# Register text functions
@text_tools.tool(description="Uppercase text")
def upper(text: str):
    return text.upper()

# Register API functions
@api_tools.tool(description="Fetch URL")
async def fetch(url: str):
    # Implementation
    return content

# Use in MAS
oxy_space = [
    oxy.HttpLLM(name="gpt4", ...),
    math_tools,
    text_tools,
    api_tools,

    # Agent with math tools only
    oxy.ReActAgent(
        name="math_agent",
        tools=["math_tools"],
        llm_model="gpt4"
    ),

    # Agent with all tools
    oxy.ReActAgent(
        name="general_agent",
        tools=["math_tools", "text_tools", "api_tools"],
        llm_model="gpt4"
    )
]
```

### 使用 Pydantic Fields

```python
from pydantic import Field

tools = oxy.FunctionHub(name="detailed_tools")

@tools.tool(description="Search for information")
async def search(
    query: str = Field(description="The search query"),
    max_results: int = Field(default=10, description="Maximum number of results to return"),
    include_snippets: bool = Field(default=True, description="Whether to include result snippets")
):
    results = await perform_search(query, max_results, include_snippets)
    return results

# Generated schema includes all Field descriptions
# LLM sees detailed parameter information
```

### 使用 OxyRequest

```python
from oxygent import OxyRequest

tools = oxy.FunctionHub(name="context_tools")

@tools.tool(description="Save data to user session")
async def save_to_session(
    oxy_request: OxyRequest,
    key: str = Field(description="Key to store data under"),
    value: str = Field(description="Value to store")
):
    # Store in session (group_data)
    oxy_request.set_group_data(key, value)

    # Also store in request (shared_data)
    oxy_request.set_shared_data(f"temp_{key}", value)

    return f"Saved {key} = {value}"

@tools.tool(description="Retrieve data from user session")
async def get_from_session(
    oxy_request: OxyRequest,
    key: str = Field(description="Key to retrieve")
):
    value = oxy_request.get_group_data(key)
    return f"{key} = {value}" if value else f"{key} not found"
```

### 使用自定义配置

```python
# Hub with custom settings
tools = oxy.FunctionHub(
    name="custom_tools",
    desc="Tools with custom configuration",
    timeout=30,              # 30 second timeout per tool
    is_permission_required=False,  # No permission needed
    retries=5,               # Retry 5 times on failure
    delay=2.0                # 2 second delay between retries
)

@tools.tool(description="May fail sometimes")
async def flaky_operation(param: str):
    # This will automatically retry up to 5 times
    result = await unreliable_api_call(param)
    return result
```

## 错误处理

### 工具执行错误

工具函数中的错误会被捕获并作为 `OxyState.FAILED` 返回：

```python
@tools.tool(description="May raise errors")
def risky_operation(param: str):
    if not param:
        raise ValueError("Parameter cannot be empty")
    return process(param)

# When called with empty string:
# - Exception is caught
# - 返回值 OxyResponse(state=FAILED, output="Error: ValueError: ...")
# - Automatically retries based on hub's retry settings
```

### 模式验证错误

无效的函数签名会在初始化期间被检测到：

```python
@tools.tool(description="Invalid signature")
def bad_function(**kwargs):  # **kwargs not supported
    return "result"

# Error during MAS.init():
# - Cannot extract parameter schema
# - May raise exception or warning
```

## 相关文档

- **[FunctionHub 指南](/docs/tools-function-hub)** - 主要文档和使用模式
- **[ReActAgent](/docs/agents-react)** - 在推理代理中使用工具
- **[MCP 工具](/docs/tools-mcp)** - 外部工具集成
- **[OxyRequest & 上下文](/docs/context)** - 详细的上下文 API 文档
- **[配置](/docs/configuration)** - 全局工具配置
