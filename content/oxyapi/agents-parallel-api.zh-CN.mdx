---
title: ParallelAgent API 参考
description: ParallelAgent 类的完整 API 参考文档，包括构造函数参数、方法和并行执行模式
icon: Users
---

## 类概述

```python
from oxygent.oxy import ParallelAgent

class ParallelAgent(LocalAgent):
    """跨多个团队成员并行执行任务的代理。

    此代理将相同任务同时分发给所有可用的团队成员
    并合并他们的响应。
    """
```

ParallelAgent 继承自 `LocalAgent`，专门为并行任务执行而设计。它将请求分发给多个团队成员（工具或子代理），收集所有响应，然后使用 LLM 将结果合并为统一的答案。

## 构造函数

### ParallelAgent()

```python
ParallelAgent(
    name: str,
    desc: str,
    llm_model: str,
    permitted_tool_name_list: list,
    **kwargs
)
```

#### 参数

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `name` | `str` | 必需 | 用于标识和调用的代理名称 |
| `desc` | `str` | 必需 | 解释代理功能的描述 |
| `llm_model` | `str` | 必需 | 用于合并并行结果的语言模型标识符 |
| `permitted_tool_name_list` | `list` | 必需 | 要并行执行的工具/代理名称列表 |

#### 继承参数（来自 LocalAgent）

ParallelAgent 继承所有 LocalAgent 参数，但通常不需要以下参数，因为它专注于并行执行：

|参数|类型|默认值|描述|
|-----------|------|---------|-------------|
| `prompt` | `可选[str]` | 自动生成 | 系统提示（自动生成用于结果合并） |
| `sub_agents` | `可选[list]` | `[]` | 子代理列表（通过 permitted_tool_name_list 管理） |
| `tools` | `可选[list]` | `[]` | 工具列表（通过 permitted_tool_name_list 管理） |
| `short_memory_size` | `int` | 配置默认值 | 短期内存大小 |
| `team_size` | `int` | `1` | 团队大小（ParallelAgent 自己管理并行性） |

#### 重要说明

ParallelAgent **不添加新的数据类字段** - 它继承 LocalAgent 的所有参数。关键区别在于执行逻辑：
- 常规 LocalAgent：顺序工具执行
- ParallelAgent：并行执行 `permitted_tool_name_list` 中的所有工具

## 方法

### _execute()

```python
async def _execute(self, oxy_request: OxyRequest) -> OxyResponse
```

跨所有团队成员并行执行请求。

#### 参数

|参数|类型|描述|
|-----------|------|-------------|
| `oxy_request` | `OxyRequest` | 要跨所有团队成员执行的请求 |

#### 返回值

|类型|描述|
|------|-------------|
| `OxyResponse` | 包含所有团队成员编号结果的合并响应 |

#### 执行流程

1. **生成并行 ID**：创建唯一的并行执行标识符
2. **并行分发**：使用 `asyncio.gather()` 同时向 `permitted_tool_name_list` 中的所有工具发送请求
3. **收集响应**：等待所有并行任务完成
4. **构建合并提示**：创建包含用户问题和所有并行结果的提示
5. **LLM 合并**：使用配置的 LLM 将并行结果合并为统一答案
6. **返回结果**：返回合并后的最终响应

#### 并行执行特性

- **真正的并行**：所有任务同时执行，而非顺序执行
- **结果编号**：每个团队成员的结果都有编号（1、2、3...）
- **自动合并**：LLM 自动分析并合并所有并行结果
- **容错性**：单个团队成员失败不会影响其他成员

### 继承方法

ParallelAgent 继承所有 LocalAgent 方法，但覆盖核心执行逻辑：

#### 来自 LocalAgent

- `init()` - 初始化代理和工具列表
- `_get_history()` - 检索对话历史
- `_build_instruction()` - 构建指令提示
- `_pre_process()` - 预处理请求
- `_before_execute()` - 预执行准备

#### 来自 BaseAgent

- `_pre_save_data()` - 保存追踪数据

#### 来自 BaseFlow

- `call()` - 执行代理
- `add_permitted_tool()` - 添加允许的工具
- `set_mas()` - 设置 MAS 引用

## 使用示例

### 基础用法实例

```python
from oxygent import MAS
from oxygent.oxy import ParallelAgent, ChatAgent, HttpLLM

oxy_space = [
    HttpLLM(
        name="default_llm",
        api_key="your-api-key",
        base_url="https://api.openai.com/v1",
        model_name="gpt-3.5-turbo"
    ),

    # Expert agents
    ChatAgent(
        name="tech_expert",
        desc="Technical expert",
        llm_model="default_llm",
        prompt="You are a technical expert..."
    ),
    ChatAgent(
        name="business_expert",
        desc="Business expert",
        llm_model="default_llm",
        prompt="You are a business expert..."
    ),
    ChatAgent(
        name="risk_expert",
        desc="Risk expert",
        llm_model="default_llm",
        prompt="You are a risk expert..."
    ),

    # Parallel agent coordinating all experts
    ParallelAgent(
        name="expert_panel",
        desc="Expert panel for parallel analysis",
        llm_model="default_llm",
        permitted_tool_name_list=[
            "tech_expert", "business_expert", "risk_expert"
        ],
        is_master=True
    )
]

async def main():
    async with MAS(oxy_space=oxy_space) as mas:
        result = await mas.call(
            callee="expert_panel",
            arguments={"query": "Evaluate the feasibility of this AI project"}
        )
        print(result.output)
```

### 多工具并行执行实例

```python
from oxygent.oxy import FunctionTool

# Create multiple function tools
def analyze_market(query: str) -> str:
    """Market analysis tool"""
    return f"Market analysis result: {query}"

def analyze_technology(query: str) -> str:
    """Technology analysis tool"""
    return f"Technology analysis result: {query}"

def analyze_finance(query: str) -> str:
    """Financial analysis tool"""
    return f"Financial analysis result: {query}"

oxy_space = [
    HttpLLM(name="default_llm", ...),

    FunctionTool(name="market_tool", func=analyze_market),
    FunctionTool(name="tech_tool", func=analyze_technology),
    FunctionTool(name="finance_tool", func=analyze_finance),

    # Parallel execution of all analysis tools
    ParallelAgent(
        name="analysis_agent",
        desc="Parallel analysis agent",
        llm_model="default_llm",
        permitted_tool_name_list=[
            "market_tool", "tech_tool", "finance_tool"
        ]
    )
]
```

### 混合代理和工具实例

```python
oxy_space = [
    HttpLLM(name="default_llm", ...),

    # Agents
    ChatAgent(name="expert_agent", ...),
    ReActAgent(name="reasoning_agent", ...),

    # Tools
    FunctionTool(name="search_tool", ...),
    MCPTool(name="calculator", ...),

    # Parallel execution of mixed types
    ParallelAgent(
        name="hybrid_agent",
        desc="Hybrid parallel execution",
        llm_model="default_llm",
        permitted_tool_name_list=[
            "expert_agent", "reasoning_agent",
            "search_tool", "calculator"
        ]
    )
]
```

## 配置选项

### 并行执行配置

- `permitted_tool_name_list`: List of tools/agents to execute in parallel
- `llm_model`: Language model for result merging

### Result Merging Configuration

ParallelAgent automatically generates merge prompts in this format:

```
You are a helpful assistant, the user's question is: {user_question}.
Please summarize the results of the parallel execution of the above tasks.

The parallel results are as following:
1. {first_result}
2. {second_result}
3. {third_result}
...
```

### Memory Management

- `short_memory_size`: Affects context length during result merging
- Recommend smaller values since parallel results already contain rich information

## Performance Characteristics

### Parallel Execution Advantages

1. **Time efficiency**: All tasks execute simultaneously, total time equals slowest task
2. **Resource utilization**: Fully utilizes system concurrency capabilities
3. **Result diversity**: Obtains analysis results from multiple perspectives

### Performance Considerations

1. **Concurrency limits**: Affected by system concurrency capabilities 和 LLM API limits
2. **Memory usage**: Simultaneous processing of multiple requests increases memory consumption
3. **Merging cost**: LLM merging step adds additional API calls

### 最佳实践

1. **Reasonable quantity**: Recommend 3-10 parallel tasks
2. **Task balancing**: Ensure parallel tasks have relatively balanced execution times
3. **Error h和ling**: Design fault tolerance for partial task failures

## 错误处理

### Common Errors

1. **Empty tool list**
   ```python
   # Error: No parallel tools specified
   ParallelAgent(
       name="agent",
       desc="test",
       llm_model="default_llm",
       permitted_tool_name_list=[]  # Empty list
   )
   ```

2. **Tool not found**
   ```python
   # Ensure all tools are registered
   ParallelAgent(
       permitted_tool_name_list=["tool1", "tool2"],  # Ensure tool1, tool2 exist
   )
   ```

3. **LLM model not configured**
   ```python
   # Ensure LLM is registered for result merging
   oxy_space = [
       HttpLLM(name="merge_llm", ...),
       ParallelAgent(llm_model="merge_llm", ...)
   ]
   ```

### Partial Failure Handling

ParallelAgent uses `asyncio.gather()` for parallel task execution:
- If any task fails, the entire parallel execution fails
- Recommend implementing appropriate error h和ling in individual tools/agents
- Consider custom implementation 包含 `return_exceptions=True`

## Use Cases

### Suitable Scenarios

1. **Multi-expert consultation**: Multiple experts analyzing the same problem simultaneously
2. **Multi-dimensional analysis**: Technical, business, risk evaluation from multiple angles
3. **Comparative assessment**: Parallel comparison of multiple solutions or options
4. **Enhanced decision-making**: Improve decision quality through diverse perspectives

### Unsuitable Scenarios

1. **Sequential dependencies**: Later tasks depend on earlier task results
2. **Resource competition**: Multiple tasks competing for same limited resources
3. **Simple queries**: Single-dimension simple questions
4. **Real-time interaction**: Scenarios requiring quick response

## Related Links

- [ParallelAgent 主文档](/docs/agents-parallel) - 概述和使用指南
- [ChatAgent API](/oxyapi/agents-chat-api) - 基础聊天代理
- [ReActAgent API](/oxyapi/agents-react-api) - 推理代理
- [ParallelFlow API](/oxyapi/flows-parallel-api) - 并行流 API
