---
title: RAG Agent API 参考
description: 使用 ReActAgent 和知识注入实现检索增强生成（RAG）模式的完整 API 参考文档
icon: Database
---

## 概述

RAG Agent 不是一个独立的类，而是通过 `ReActAgent` 结合知识注入函数实现的设计模式。它通过检索相关的外部知识并在生成响应前将其注入提示中，来提高答案的准确性和可控性。

## 核心组件

### 1. ReActAgent 基础

```python
from oxygent.oxy import ReActAgent

# 基于 ReActAgent 的 RAG 实现
rag_agent = ReActAgent(
    name="rag_agent",
    desc="Retrieval-Augmented Generation agent",
    llm_model="default_llm",
    prompt=INSTRUCTION,  # Prompt containing knowledge placeholders
    func_process_input=update_query,  # Knowledge injection function
)
```

### 2. 知识注入函数

```python
def update_query(oxy_request: OxyRequest) -> OxyRequest:
    """知识注入函数，在执行前将检索到的知识添加到请求中。

    Args:
        oxy_request: 原始请求对象

    Returns:
        OxyRequest: 注入知识后的请求对象
    """
    current_query = oxy_request.get_query()

    # 执行知识检索
    knowledge = retrieval(current_query)

    # 将知识注入到参数中
    oxy_request.arguments["knowledge"] = knowledge

    return oxy_request
```

### 3. 检索函数

```python
def retrieval(query: str) -> str:
    """基于查询检索相关知识。

    Args:
        query: 用户查询字符串

    Returns:
        str: 检索到的相关知识文本
    """
    # 实现具体的检索逻辑
    # 例如：向量数据库查询、搜索服务、知识库查询等
    return retrieved_knowledge
```

## API 参考

### update_query()

知识注入的核心函数，在 ReActAgent 执行前调用。

```python
def update_query(oxy_request: OxyRequest) -> OxyRequest
```

#### 参数

|参数|类型|描述|
|-----------|------|-------------|
| `oxy_request` | `OxyRequest` | 请求对象，包含用户查询和上下文 |

#### 返回值

|类型|描述|
|------|-------------|
| `OxyRequest` | 包含注入知识的请求对象 |

#### 实现要点

1. **获取查询**：使用 `oxy_request.get_query()` 获取用户查询
2. **执行检索**：调用检索函数获取相关知识
3. **注入知识**：将知识添加到 `oxy_request.arguments["knowledge"]`
4. **返回请求**：返回修改后的请求对象

#### 示例实现

```python
def update_query(oxy_request: OxyRequest) -> OxyRequest:
    current_query = oxy_request.get_query()

    # 简单的知识检索示例
    def retrieval(query):
        # 这里应该是实际的检索逻辑
        knowledge_base = {
            "AI": "Artificial intelligence related knowledge...",
            "Python": "Python programming related knowledge...",
            "Database": "Database related knowledge..."
        }

        # 简单的关键词匹配
        for key, knowledge in knowledge_base.items():
            if key in query:
                return knowledge

        return "No relevant knowledge found"

    # 注入检索到的知识
    oxy_request.arguments["knowledge"] = retrieval(current_query)
    return oxy_request
```

### retrieval()

检索函数的标准接口，具体实现取决于知识源。

```python
def retrieval(query: str) -> str
```

#### 参数

|参数|类型|描述|
|-----------|------|-------------|
| `query` | `str` | 用户查询字符串 |

#### 返回值

|类型|描述|
|------|-------------|
| `str` | 检索到的知识文本，多个知识片段用换行符连接 |

#### 实现变体

##### 向量数据库检索

```python
def retrieval(query: str) -> str:
    """使用向量数据库进行语义检索"""
    # 使用嵌入模型编码查询
    query_embedding = embedding_model.encode(query)

    # 在向量数据库中搜索
    results = vector_db.search(query_embedding, top_k=5)

    # 合并检索结果
    knowledge_pieces = [result.text for result in results]
    return "\n".join(knowledge_pieces)
```

##### 搜索引擎检索

```python
def retrieval(query: str) -> str:
    """使用搜索引擎进行检索"""
    search_results = search_engine.search(query, num_results=3)

    knowledge_pieces = []
    for result in search_results:
        knowledge_pieces.append(f"Source: {result.title}\nContent: {result.snippet}")

    return "\n\n".join(knowledge_pieces)
```

##### 文档数据库检索

```python
def retrieval(query: str) -> str:
    """从文档数据库检索"""
    # 使用全文搜索或关键词匹配
    documents = document_db.search(query)

    relevant_docs = []
    for doc in documents[:5]:  # 取前5个相关文档
        relevant_docs.append(doc.content)

    return "\n---\n".join(relevant_docs)
```

## 提示模板

RAG Agent 需要特殊的提示模板来处理注入的知识。

### 标准 RAG 提示模板

```python
INSTRUCTION = """
You are a helpful assistant and can use these tools:
${tools_description}

Knowledge base information:
${knowledge}

Use the knowledge base information to provide accurate answers.
If you need to use tools, follow the standard tool calling format.

Important notes:
1. When you have collected enough information to answer the user's question, please respond in the following format:
<think>Your reasoning (if analysis is needed)</think>
Your response content

2. When you find that the user's question lacks certain conditions, you can ask them back:
<think>Your reasoning (if analysis is needed)</think>
Your follow-up question to the user

3. When you need to use a tool, you must respond **only** 包含 the following exact JSON object format:
{
    "think": "Your reasoning (if analysis is needed)",
    "tool_name": "Tool name",
    "arguments": {
        "Parameter name": "Parameter value"
    }
}
"""
```

### 知识占位符

- `${knowledge}`: 注入检索知识的占位符
- `${tools_description}`: 工具描述占位符
- 可以添加其他自定义占位符

## 完整实现示例

### 基础 RAG 实现

```python
import asyncio
from oxygent import MAS, OxyRequest, oxy
from oxygent.utils.env_utils import get_env_var

# RAG 提示模板
INSTRUCTION = """
You are a helpful assistant and can use these tools:
${tools_description}

Knowledge base information:
${knowledge}

Use the knowledge base information to provide accurate answers.
If you need to use tools, follow the standard tool calling format.
"""

def update_query(oxy_request: OxyRequest) -> OxyRequest:
    """知识注入函数"""
    current_query = oxy_request.get_query()

    def retrieval(query):
        # 模拟知识库检索
        knowledge_base = [
            "OxyGent is a multi-agent system framework",
            "Supports multiple types of agents and tools",
            "Provides flexible configuration and extension capabilities"
        ]
        return "\n".join(knowledge_base)

    # 注入知识
    oxy_request.arguments["knowledge"] = retrieval(current_query)
    return oxy_request

# 创建 RAG 系统
oxy_space = [
    oxy.HttpLLM(
        name="default_llm",
        api_key=get_env_var("DEFAULT_LLM_API_KEY"),
        base_url=get_env_var("DEFAULT_LLM_BASE_URL"),
        model_name=get_env_var("DEFAULT_LLM_MODEL_NAME"),
        llm_params={"temperature": 0.01},
    ),
    oxy.ReActAgent(
        name="rag_agent",
        desc="Retrieval-Augmented Generation agent",
        llm_model="default_llm",
        prompt=INSTRUCTION,
        func_process_input=update_query,
        is_master=True,
    ),
]

async def main():
    async with MAS(oxy_space=oxy_space) as mas:
        result = await mas.call(
            callee="rag_agent",
            arguments={"query": "What is OxyGent?"}
        )
        print(result.output)

if __name__ == "__main__":
    asyncio.run(main())
```

### 高级 RAG 实现

```python
import json
from typing import List, Dict

class AdvancedRAG:
    """高级 RAG 实现类"""

    def __init__(self, knowledge_sources: List[Dict]):
        self.knowledge_sources = knowledge_sources

    def multi_source_retrieval(self, query: str) -> str:
        """多源知识检索"""
        all_knowledge = []

        for source in self.knowledge_sources:
            if source["type"] == "vector_db":
                knowledge = self._vector_search(query, source)
            elif source["type"] == "document_db":
                knowledge = self._document_search(query, source)
            elif source["type"] == "api":
                knowledge = self._api_search(query, source)
            else:
                continue

            if knowledge:
                all_knowledge.append(f"[{source['name']}] {knowledge}")

        return "\n\n".join(all_knowledge)

    def _vector_search(self, query: str, source: Dict) -> str:
        """向量数据库搜索"""
        # 实现向量搜索逻辑
        pass

    def _document_search(self, query: str, source: Dict) -> str:
        """文档数据库搜索"""
        # 实现文档搜索逻辑
        pass

    def _api_search(self, query: str, source: Dict) -> str:
        """API 搜索"""
        # 实现 API 搜索逻辑
        pass

# 使用高级 RAG
knowledge_sources = [
    {"name": "Technical Docs", "type": "vector_db", "config": {...}},
    {"name": "FAQ Database", "type": "document_db", "config": {...}},
    {"name": "Real-time Search", "type": "api", "config": {...}},
]

advanced_rag = AdvancedRAG(knowledge_sources)

def advanced_update_query(oxy_request: OxyRequest) -> OxyRequest:
    """高级知识注入函数"""
    current_query = oxy_request.get_query()

    # 多源检索
    knowledge = advanced_rag.multi_source_retrieval(current_query)

    # 注入知识
    oxy_request.arguments["knowledge"] = knowledge

    # 可以添加其他元数据
    oxy_request.arguments["retrieval_timestamp"] = get_current_timestamp()
    oxy_request.arguments["knowledge_sources"] = len(knowledge_sources)

    return oxy_request
```

## 配置选项

### 知识注入配置

|配置项|类型|描述|
|---------------|------|-------------|
| `knowledge_placeholder` | `str` | 知识占位符名称，默认为 "knowledge" |
| `max_knowledge_length` | `int` | 最大知识长度限制 |
| `retrieval_timeout` | `float` | 检索超时时间（秒） |
| `fallback_knowledge` | `str` | 检索失败时的备用知识 |

### 检索配置

|配置项|类型|描述|
|---------------|------|-------------|
| `top_k` | `int` | 检索结果数量 |
| `similarity_threshold` | `float` | 相似度阈值 |
| `enable_reranking` | `bool` | 是否启用重排序 |
| `knowledge_sources` | `List[Dict]` | 知识源配置列表 |

## 性能优化

### 检索优化

1. **缓存机制**：缓存常见查询的检索结果
2. **异步检索**：使用异步方法进行检索
3. **批量检索**：批量处理多个查询
4. **索引优化**：优化向量数据库索引

### 知识注入优化

1. **长度控制**：限制注入知识的长度
2. **相关性过滤**：过滤低相关性知识
3. **格式优化**：优化知识格式和结构
4. **上下文管理**：管理知识在上下文中的位置

## 错误处理

### 常见错误

1. **检索失败**
   ```python
   def safe_retrieval(query: str) -> str:
       try:
           return retrieval(query)
       except Exception as e:
           logger.error(f"检索失败: {e}")
           return "检索服务暂时不可用"
   ```

2. **知识注入失败**
   ```python
   def safe_update_query(oxy_request: OxyRequest) -> OxyRequest:
       try:
           knowledge = safe_retrieval(oxy_request.get_query())
           oxy_request.arguments["knowledge"] = knowledge
       except Exception as e:
           logger.error(f"知识注入失败: {e}")
           oxy_request.arguments["knowledge"] = ""

       return oxy_request
   ```

3. **超时处理**
   ```python
   import asyncio

   async def timeout_retrieval(query: str, timeout: float = 5.0) -> str:
       try:
           return await asyncio.wait_for(
               async_retrieval(query),
               timeout=timeout
           )
       except asyncio.TimeoutError:
           return "检索超时，使用默认知识"
   ```

## 最佳实践

### 检索策略

1. **多样化检索**：使用多种检索方法
2. **相关性排序**：按相关性对结果进行排序
3. **知识去重**：去除重复的知识片段
4. **上下文感知**：考虑对话上下文进行检索

### 知识管理

1. **知识质量**：确保知识库质量和时效性
2. **知识结构**：合理组织知识结构
3. **知识更新**：定期更新知识库内容
4. **知识验证**：验证检索知识的准确性

### 提示设计

1. **清晰指令**：提供清晰的知识使用指令
2. **格式规范**：标准化提示中的知识格式
3. **优先级**：明确知识和工具的使用优先级
4. **错误处理**：处理知识不足或错误的情况

## 相关链接

- [RAG Agent 主文档](/docs/agents-rag) - 概述和使用指南
- [ReActAgent API](/oxyapi/agents-react-api) - 基础推理代理 API
- [Context 文档](/docs/context) - 上下文管理系统
- [ChatAgent API](/oxyapi/agents-chat-api) - 聊天代理 API
